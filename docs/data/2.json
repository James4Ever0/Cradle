{
    "200": {
        "file_id": 20,
        "content": "            game_image, minimap_image = take_screenshot(timestep, game_screen_region, minimap_region, draw_axis=False)\n            theta, measure = match_template(os.path.join(save_dir, f\"minimap_{timestep}.jpg\"), waypoint_marker_filename, config.resolution_ratio, debug=False)\n            logger.debug(f\"distance  {measure['distance']}\")\n            if measure['distance'] < terminal_threshold * 1.5:\n                stop_horse()\n            if measure['distance'] < terminal_threshold and abs(theta) < 90:\n                logger.debug('success! Reach the red marker.')\n                stop_horse()\n                time.sleep(1)\n                theta, measure = match_template(os.path.join(save_dir, f\"minimap_{timestep}.jpg\"), waypoint_marker_filename, config.resolution_ratio, debug=False)\n                turn(theta * 1.2)\n                break\n            turn_angle = calculate_turn_angle(timestep, debug)\n    except Exception as e:\n        logger.warn(f\"Error in cv_navigation: {e}. Usually not a problem.\")\n        stop_horse()",
        "type": "code",
        "location": "/cradle/gameio/composite_skills/navigation.py:71-92"
    },
    "201": {
        "file_id": 20,
        "content": "The code snippet captures game screenshots and minimap images, then measures the distance and angle to a waypoint marker. If the distance is below a certain threshold and angle isn't too sharp, it stops the horse, turns towards the marker, and ends if the angle is within range. If any exception occurs, it logs a warning and stops the horse.",
        "type": "comment"
    },
    "202": {
        "file_id": 20,
        "content": "def calculate_turn_angle(tid, debug = False, show_image = False):\n    output_dir = config.work_dir\n    minimap_path = output_dir + \"/minimap_\" + str(tid) + \".jpg\"\n    output_path = output_dir + \"/direction_map_\" + str(tid) + \".jpg\"\n    image = cv2.imread(minimap_path)\n    # Convert the image to HSV space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Calculate image center\n    image_center = np.array([image.shape[1] // 2, image.shape[0] // 2])\n    width, height  = image_center\n    center_x = width\n    center_y = height\n    # Define range for red color\n    lower_red_1 = np.array([0, 80,80])\n    upper_red_1 = np.array([10,255,255])\n    # Threshold the HSV image to get the red regions\n    mask1 = cv2.inRange(hsv, lower_red_1, upper_red_1)\n    mask = mask1\n    kernel = np.ones((3,3), np.uint8)\n    mask_upper_bottom = cv2.dilate(mask, kernel, iterations = 2)\n    def get_contour(mask):\n        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        # Sort contours by area and get the top 5",
        "type": "code",
        "location": "/cradle/gameio/composite_skills/navigation.py:95-126"
    },
    "203": {
        "file_id": 20,
        "content": "This function calculates the turn angle based on an image and returns the contours of the top 5 areas sorted by area. The code reads an image, converts it to HSV space, calculates the image center, defines a range for red color, creates a mask, dilates the mask, finds contours in the mask and sorts them by area.",
        "type": "comment"
    },
    "204": {
        "file_id": 20,
        "content": "        contours = sorted(contours, key=cv2.contourArea, reverse=True)[:5]\n        # Find the minimum distance from each contour to the image center\n        def min_distance_from_center(contour):\n            return min([  np.linalg.norm(np.array(point[0]) - image_center) for point in contour])\n        # Find the contour with the minimum distance to the image center\n        closest_contour = min(contours, key=min_distance_from_center)\n        output_mask = np.zeros_like(mask)\n        contour = cv2.drawContours(output_mask, [closest_contour], -1, (1), thickness=cv2.FILLED) * 255\n        lines = None\n        minLineLength = width / 15\n        threshold = 10\n        while (lines is None or len(lines) < 10) and threshold > 0:\n            lines = cv2.HoughLinesP(contour, 1, np.pi / 180, threshold=threshold, minLineLength= minLineLength, maxLineGap=100)\n            if minLineLength <= 10:\n                threshold -= 1\n            minLineLength /= 1.1\n        if threshold == 0:\n            return None\n        return lines",
        "type": "code",
        "location": "/cradle/gameio/composite_skills/navigation.py:127-148"
    },
    "205": {
        "file_id": 20,
        "content": "This function uses OpenCV to find the contour with the minimum distance to the image center and applies a HoughLinesP transformation on that contour to detect lines. The parameters control the line detection threshold, minimum line length, and maximum gap between lines. If no lines are detected or the number of lines is less than 10 after several iterations, the function returns None. Otherwise, it returns the detected lines.",
        "type": "comment"
    },
    "206": {
        "file_id": 20,
        "content": "    lines = get_contour(mask)\n    lines_upper_bottom = get_contour(mask_upper_bottom)\n    if lines is None or lines_upper_bottom is None:\n        return 0\n    line_img = np.zeros_like(image)\n    upper_bottom_img = np.zeros_like(image)\n    def slope_to_angle(x1, y1, x2, y2):\n        dx = x2 - x1\n        dy = y2 - y1\n        angle_radians = math.atan2(dy, dx)\n        angle_degrees = math.degrees(angle_radians)\n        if angle_degrees < 0:\n            angle_degrees += 180\n        return angle_degrees\n    # Calcualte the average slope with the lines near the center of the mini-map\n    central_line_angles = []\n    central_dots = []\n    distance_threshold = height / 50\n    while len(central_line_angles) < 5:\n        central_line_angles = []\n        central_dots = []\n        for line in lines:\n            x1, y1, x2, y2 = line[0]\n            cv2.line(line_img, (x1, y1), (x2, y2), (255), 1)\n            cv2.line(image, (x1, y1), (x2, y2), (255), 1)\n            if (x1 - center_x)**2 + (y1 -center_y)**2 < distance_threshold**2 or (x2 - center_x)**2 + (y2 -center_y)**2 < distance_threshold**2:",
        "type": "code",
        "location": "/cradle/gameio/composite_skills/navigation.py:150-187"
    },
    "207": {
        "file_id": 20,
        "content": "This code calculates the average slope of lines near the center of a mini-map by iterating through each line, checking its distance from the center point. It creates two blank images and uses the slope_to_angle function to convert slopes into angles in degrees. The process continues until it has gathered 5 such angle values for the central lines.",
        "type": "comment"
    },
    "208": {
        "file_id": 20,
        "content": "                angle_degrees = slope_to_angle(x1, y1, x2, y2)\n                central_line_angles.append(angle_degrees)\n                if (x1 - center_x)**2 + (y1 -center_y)**2 < (x2 - center_x)**2 + (y2 - center_y)**2:\n                    central_dots.append((x1, y1))\n                else:\n                    central_dots.append((x2, y2))\n        distance_threshold *= 1.2\n    if debug:\n        logger.debug(f\"distance_threshold {distance_threshold}\")\n        logger.debug(f\"central_dots {central_dots}\")\n    # Use the average of the y of the chosen lines to determine the red line is in the upper/bottom half of the mini-map\n    central_line_y = []\n    distance_threshold = height / 5\n    while not central_line_y:\n        for line in lines_upper_bottom:\n            cv2.line(upper_bottom_img, (x1, y1), (x2, y2), (255), 1)\n            x1, y1, x2, y2 = line[0]\n            if (x1 - center_x)**2 + (y1 - center_y)**2 < distance_threshold**2 or (x2 - center_x)**2 + (y2 - center_y)**2 < distance_threshold**2:\n                if (x1 - center_x)**2 + (y1 - center_y)**2 > (x2 - center_x)**2 + (y2 - center_y)**2:",
        "type": "code",
        "location": "/cradle/gameio/composite_skills/navigation.py:189-213"
    },
    "209": {
        "file_id": 20,
        "content": "This code calculates the angle and determines central dots of lines within a specified distance threshold. It then calculates the y-coordinate of central lines to determine if the red line is in the upper or bottom half of the mini-map. The code also logs debug information, such as the distance threshold and central dots, for potential troubleshooting.",
        "type": "comment"
    },
    "210": {
        "file_id": 20,
        "content": "                    central_line_y.append(y1)\n                else:\n                    central_line_y.append(y2)\n        distance_threshold *= 1.2\n    angle_degrees = np.average(central_line_angles)\n    is_upper = np.average(central_line_y)  <= center_y * 1.05\n    deviation_angle_degrees = None\n    deviation_threshold = width / 10\n    central_dot_upper = True\n    if len(central_dots) > 0:\n        average_dot = np.average(central_dots, axis=0)\n        if (average_dot[0] - center_x)**2 + (average_dot[1] - center_y)**2 > deviation_threshold**2:\n            deviation_angle_degrees = slope_to_angle(average_dot[0], average_dot[1], center_x, center_y)\n            central_dot_upper = average_dot[1] <= center_y\n    def cal_real_turn_angle(angle_degrees, is_upper):\n        if angle_degrees > 90:\n            angle_degrees -= 180\n        # calculate turn angle(the angle between the red line and normal line)\n        # positive: right, negative: left\n        if angle_degrees < 0:\n            turn_angle = 90 + angle_degrees",
        "type": "code",
        "location": "/cradle/gameio/composite_skills/navigation.py:214-240"
    },
    "211": {
        "file_id": 20,
        "content": "This code calculates the central line y-coordinates, updates distance threshold, determines if upper or lower based on average central line y, checks for deviation from center based on average central dots, calculates real turn angle considering the angle and whether it's upper or lower.",
        "type": "comment"
    },
    "212": {
        "file_id": 20,
        "content": "        else:\n            turn_angle = -90 + angle_degrees\n        # process the angle if the red line is in the bottom half of the mini-map\n        if not is_upper:\n            if turn_angle > 0:\n                real_turn_angle = turn_angle - 180\n            else:\n                real_turn_angle = turn_angle + 180\n        else:\n            real_turn_angle = turn_angle\n        return real_turn_angle\n    red_line_turn_angle = cal_real_turn_angle(angle_degrees, is_upper)\n    real_turn_angle = red_line_turn_angle\n    if deviation_angle_degrees:\n        deviation_turn_angle = cal_real_turn_angle(deviation_angle_degrees, central_dot_upper)\n        if real_turn_angle * deviation_turn_angle > 0 and is_upper == central_dot_upper:\n            real_turn_angle = (real_turn_angle + deviation_turn_angle) / 2\n        else:\n            real_turn_angle = deviation_turn_angle\n    real_turn_angle *= 1.1\n    angle_radians = math.radians(real_turn_angle)\n    slope = math.tan(angle_radians)\n    if slope == 0:\n        slope = 0.0001",
        "type": "code",
        "location": "/cradle/gameio/composite_skills/navigation.py:241-268"
    },
    "213": {
        "file_id": 20,
        "content": "This function calculates the final turn angle based on the input angle_degrees and whether it is in the upper or lower half of the mini-map. It considers potential deviations by calculating a deviation_turn_angle, and adjusts the real_turn_angle accordingly. Finally, it scales the angle to account for small numerical precision issues and converts it to radians before calculating the slope.",
        "type": "comment"
    },
    "214": {
        "file_id": 20,
        "content": "    slope = 1 / slope\n    if debug:\n        logger.debug(f\"slope {slope}\")\n        logger.debug(f\"red_line_turn_angle {red_line_turn_angle}\")\n        logger.debug(f\"is_upper {is_upper}\")\n        if deviation_angle_degrees:\n            logger.debug(f\"deviation_turn_angle {deviation_turn_angle}\")\n            logger.debug(f\"central_dot_upper {central_dot_upper}\")\n        logger.debug(f\"real turn angle {real_turn_angle}\")\n    # Draw green line to show the calculated turn direction\n    offset = 50\n    if abs(slope * offset) >= center_y:\n        offset = (center_y - 1) / abs(slope)\n    end_x = center_x + offset\n    start_x = center_x - offset\n    end_y = center_y - slope * offset\n    start_y = center_y + slope * offset\n    cv2.line(image, (int(start_x), int(start_y)), (int(end_x), int(end_y)), (0, 255, 0), 2)\n    if len(central_dots) > 0 and (average_dot[0] - center_x)**2 + (average_dot[1] - center_y)**2 > deviation_threshold**2:\n        point = (int(average_dot[0]), int(average_dot[1]))\n        color = (0, 255, 255)",
        "type": "code",
        "location": "/cradle/gameio/composite_skills/navigation.py:269-295"
    },
    "215": {
        "file_id": 20,
        "content": "Draws a green line to indicate the calculated turn direction. If central dots exist and average dot is outside of deviation threshold, mark it with a light blue dot.",
        "type": "comment"
    },
    "216": {
        "file_id": 20,
        "content": "        cv2.circle(image, point, 5, color, -1)\n    cv2.imwrite(output_path, image)\n    if show_image:\n        cv2.imshow('upper', upper_bottom_img)\n        cv2.imshow('Image with Lines', line_img)\n        cv2.imshow('Image', image)\n        cv2.imshow('mask_upper_bottom', mask_upper_bottom)\n        cv2.waitKey(0)\n        cv2.destroyAllWindows()\n    return real_turn_angle\n__all__ = [\n    \"navigate_path\",\n]",
        "type": "code",
        "location": "/cradle/gameio/composite_skills/navigation.py:296-313"
    },
    "217": {
        "file_id": 20,
        "content": "Code draws a circle on an image, writes the image to output path, displays multiple images using cv2.imshow, waits for user input before closing windows, and returns the real turn angle.",
        "type": "comment"
    },
    "218": {
        "file_id": 21,
        "content": "/cradle/gameio/game_manager.py",
        "type": "filepath"
    },
    "219": {
        "file_id": 21,
        "content": "GameManager initializes and manages game processes, offers functions like pausing, switching games, and skill management; includes methods for capturing screenshots, extracting minimaps, and interacting with SkillRegistry.",
        "type": "summary"
    },
    "220": {
        "file_id": 21,
        "content": "import time\nfrom typing import Tuple\nfrom cradle.config import Config\nfrom cradle.gameio import IOEnvironment\nfrom cradle.log import Logger\nfrom cradle.gameio.lifecycle.ui_control import take_screenshot, segment_minimap, switch_to_game, pause_game, unpause_game, exit_back_to_pause\nfrom cradle.gameio.composite_skills.navigation import navigate_path\nfrom cradle.gameio.skill_registry import SkillRegistry\nfrom cradle import constants\nconfig = Config()\nlogger = Logger()\nio_env = IOEnvironment()\nclass GameManager:\n    def __init__(\n        self,\n        env_name,\n        embedding_provider = None\n    ):\n        self.env_name = env_name\n        self.skill_registry = SkillRegistry(local_path = config.skill_local_path,\n                                            from_local = config.skill_from_local,\n                                            store_path = config.work_dir,\n                                            skill_scope = config.skill_scope,\n                                            embedding_provider = embedding_provider)",
        "type": "code",
        "location": "/cradle/gameio/game_manager.py:1-29"
    },
    "221": {
        "file_id": 21,
        "content": "This code imports necessary modules and classes, initializes a logger, IO environment, and configuration, and defines the GameManager class. It takes an environment name and an optional embedding provider as parameters in its constructor. The skill_registry is initialized with local path, from local flag, store path, skill scope, and optional embedding provider.",
        "type": "comment"
    },
    "222": {
        "file_id": 21,
        "content": "    def pause_game(self, screen_type=constants.GENERAL_GAME_INTERFACE):\n        if screen_type==constants.GENERAL_GAME_INTERFACE or screen_type==constants.PAUSE_INTERFACE or screen_type==constants.RADIAL_INTERFACE:\n            pause_game()\n    def unpause_game(self):\n        unpause_game()\n    def switch_to_game(self):\n        switch_to_game()\n    def exit_back_to_pause(self):\n        exit_back_to_pause()\n    def get_skill_information(self, skill_list):\n        filtered_skill_library = []\n        for skill_name in skill_list:\n            skill_item = self.skill_registry.get_from_skill_library(skill_name)\n            filtered_skill_library.append(skill_item)\n        return filtered_skill_library\n    def add_new_skill(self, skill_code, overwrite = True):\n        return self.skill_registry.register_skill_from_code(skill_code = skill_code, overwrite = overwrite)\n    def delete_skill(self, skill_name):\n        self.skill_registry.delete_skill(skill_name)\n    def retrieve_skills(self, query_task, skill_num, screen_type):",
        "type": "code",
        "location": "/cradle/gameio/game_manager.py:32-69"
    },
    "223": {
        "file_id": 21,
        "content": "This code contains functions to pause, unpause, switch to game, exit back to pause, retrieve skills based on query and skill number, filter skill library, add new skill, and delete existing skill. It is likely part of a larger game management system.",
        "type": "comment"
    },
    "224": {
        "file_id": 21,
        "content": "        return self.skill_registry.retrieve_skills(query_task, skill_num, screen_type)\n    def register_available_skills(self, candidates):\n        self.skill_registry.register_available_skills(candidates)\n    def get_skill_library_in_code(self, skill) -> Tuple[str, str]:\n        return self.skill_registry.get_skill_library_in_code(skill)\n    def execute_navigation(self, action):\n        # Execute action\n        total_time_step = 500\n        if action == \"navigate_path\":\n            time.sleep(2)\n            navigate_path(total_time_step)\n    def execute_actions(self, actions):\n        exec_info = {\n            \"executed_skills\" : [],\n            \"last_skill\" : '',\n            \"errors\" : False,\n            \"errors_info\": \"\"\n        }\n        io_env.update_timeouts()\n        if actions is None or len(actions) == 0 or actions == '' or actions[0] == '':\n            logger.warn(f\"No actions to execute! Executing nop.\")\n            self.skill_registry.execute_nop_skill()\n            exec_info[\"errors\"] = True\n            exec_info[\"errors_info\"] = \"No actions to execute!\"",
        "type": "code",
        "location": "/cradle/gameio/game_manager.py:70-108"
    },
    "225": {
        "file_id": 21,
        "content": "The code defines a GameManager class, which interacts with SkillRegistry to retrieve skills, register available skills, and get skill library in code. The execute_navigation function executes navigation action with a total time step of 500ms. The execute_actions function handles the execution of actions passed as a parameter and updates the executed skills list and handles errors if any.",
        "type": "comment"
    },
    "226": {
        "file_id": 21,
        "content": "            return exec_info\n        skill_name = '-'\n        skill_params = '-'\n        try:\n            for skill in actions:\n                skill_name, skill_params = self.skill_registry.convert_expression_to_skill(skill)\n                logger.write(f\"Executing skill: {skill_name} with params: {skill_params}\")\n                # Enable OCR for composite skills, start the ocr check\n                if skill_name in config.ocr_check_composite_skill_names:\n                    if not config.ocr_fully_ban:\n                        config.ocr_different_previous_text = False\n                        config.enable_ocr = True\n                    else:\n                        config.ocr_different_previous_text = False\n                        config.enable_ocr = False\n                if \"navigate\" in skill_name:\n                    self.execute_navigation(skill_name)\n                else:\n                    self.skill_registry.execute_skill(name=skill_name, params=skill_params)\n                exec_info[\"executed_skills\"].append(skill)",
        "type": "code",
        "location": "/cradle/gameio/game_manager.py:109-135"
    },
    "227": {
        "file_id": 21,
        "content": "This code handles the execution of skills based on expressions. It iterates through each skill in the actions list, converts it to a skill name and params, then executes it using the SkillRegistry class. If the skill name is a composite skill from the config's ocr_check_composite_skill_names, it toggles the OCR enable status based on the config's ocr_fully_ban setting. If the skill contains \"navigate\", it calls execute_navigation function. The executed skills are appended to the exec_info dictionary.",
        "type": "comment"
    },
    "228": {
        "file_id": 21,
        "content": "                exec_info[\"last_skill\"] = skill\n                self.post_action_wait()\n                logger.write(f\"Finished executing skill: {skill} and wait.\")\n        except Exception as e:\n            msg = f'Error executing skill {skill_name} with params {skill_params} (from actions: {actions}):\\n{e}'\n            logger.error(msg)\n            exec_info[\"errors\"] = True\n            exec_info[\"errors_info\"] = msg\n        # @TODO re-add hold timeout check call\n        return exec_info\n    # Currently all actions have wait in them, if needed\n    def post_action_wait(self):\n        #time.sleep(config.DEFAULT_POST_ACTION_WAIT_TIME)\n        time.sleep(1)\n    def capture_screen(self, include_minimap = False):\n        tid = time.time()\n        return take_screenshot(tid, include_minimap=include_minimap)\n    def extract_minimap(self, screenshot_path):\n        return segment_minimap(screenshot_path)\n    def list_session_screenshots(self, session_dir: str = config.work_dir):\n        return io_env.list_session_screenshots(session_dir)",
        "type": "code",
        "location": "/cradle/gameio/game_manager.py:136-168"
    },
    "229": {
        "file_id": 21,
        "content": "This code snippet defines a game manager class with methods for executing skills, waiting after an action, capturing screenshots, extracting minimap from the screenshot, and listing session screenshots. The post_action_wait() method adds a wait time after each action, while the capture_screen() method takes a screenshot with or without minimap. The extract_minimap() method extracts the minimap from a provided screenshot path. Lastly, the list_session_screenshots() method lists screenshots in a specified session directory.",
        "type": "comment"
    },
    "230": {
        "file_id": 21,
        "content": "    def store_skills(self):\n        self.skill_registry.store_skills()\n    def cleanup_io(self):\n        io_env.release_held_keys()\n        io_env.release_held_buttons()",
        "type": "code",
        "location": "/cradle/gameio/game_manager.py:171-177"
    },
    "231": {
        "file_id": 21,
        "content": "The `store_skills` method saves the skills to the skill registry, while the `cleanup_io` function releases held keys and buttons in the IO environment.",
        "type": "comment"
    },
    "232": {
        "file_id": 22,
        "content": "/cradle/gameio/io_env.py",
        "type": "filepath"
    },
    "233": {
        "file_id": 22,
        "content": "This code manages inputs, logs warnings, and handles game events using AutoHotkey for mouse actions and pydirectinput for key input. It includes screenshots, mouse normalization, coordinate conversion, aliasing, mapping, handling special keys, and adjusting theta based on mouse move factor configuration.",
        "type": "summary"
    },
    "234": {
        "file_id": 22,
        "content": "from typing import (\n    Any,\n    Dict,\n    List,\n    Tuple,\n)\nimport os\nimport time\nimport ctypes\nfrom ahk import AHK\nimport pydirectinput\nfrom cradle.utils import Singleton\nfrom cradle.config import Config\nfrom cradle.log import Logger\nconfig = Config()\nlogger = Logger()\nPUL = ctypes.POINTER(ctypes.c_ulong)\nclass KeyBdInput(ctypes.Structure):\n    _fields_ = [\n        (\"wVk\", ctypes.c_ushort),\n        (\"wScan\", ctypes.c_ushort),\n        (\"dwFlags\", ctypes.c_ulong),\n        (\"time\", ctypes.c_ulong),\n        (\"dwExtraInfo\", PUL),\n    ]\nclass HardwareInput(ctypes.Structure):\n    _fields_ = [\n        (\"uMsg\", ctypes.c_ulong),\n        (\"wParamL\", ctypes.c_short),\n        (\"wParamH\", ctypes.c_ushort),\n    ]\nclass MouseInput(ctypes.Structure):\n    _fields_ = [\n        (\"dx\", ctypes.c_long),\n        (\"dy\", ctypes.c_long),\n        (\"mouseData\", ctypes.c_ulong),\n        (\"dwFlags\", ctypes.c_ulong),\n        (\"time\", ctypes.c_ulong),\n        (\"dwExtraInfo\", PUL),\n    ]\nclass Input_I(ctypes.Union):\n    _fields_ = [(\"ki\", KeyBdInput), (\"mi\", MouseInput), (\"hi\", HardwareInput)]",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:1-55"
    },
    "235": {
        "file_id": 22,
        "content": "This code imports necessary modules and defines custom structures for handling keyboard, mouse, and hardware input. It also creates a union structure to handle different types of inputs.",
        "type": "comment"
    },
    "236": {
        "file_id": 22,
        "content": "class Input(ctypes.Structure):\n    _fields_ = [(\"type\", ctypes.c_ulong), (\"ii\", Input_I)]\nclass IOEnvironment(metaclass=Singleton):\n    \"\"\"\n    Wrapper for resources to interact with the game to make sure they're available where needed and multiple instances are not created.\n    \"\"\"\n    # Windows API constants\n    MOUSEEVENTF_MOVE = 0x0001\n    MOUSEEVENTF_ABSOLUT = 0x8000\n    WIN_NORM_MAX = 65536 # int max val\n    # Constants\n    RIGHT_MOUSE_BUTTON = 'Right'\n    LEFT_MOUSE_BUTTON = 'Left'\n    MIDDLE_MOUSE_BUTTON = 'Middle'\n    right_mouse_button = RIGHT_MOUSE_BUTTON\n    left_mouse_button = LEFT_MOUSE_BUTTON\n    middle_mouse_button = MIDDLE_MOUSE_BUTTON\n    WHEEL_UP_MOUSE_BUTTON = 'WU'\n    WHEEL_DOWN_MOUSE_BUTTON = 'WD'\n    MIN_DURATION = 2 # In seconds\n    HOLD_DEFAULT_BLOCK_TIME = 2\n    RELEASE_DEFAULT_BLOCK_TIME = 0.5\n    MAX_ITERATIONS = 3\n    KEY_KEY = 'key'\n    BUTTON_KEY = 'button'\n    EXPIRATION_KEY = 'expiration'\n    # All key interactions are now tracked and use the same calling structure\n    # - Release is equivalent to keyUp. I.e., release a key that was pressed or held.",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:58-94"
    },
    "237": {
        "file_id": 22,
        "content": "This code defines classes and constants for handling game input and environment interaction. It includes constants for different types of mouse buttons, key interactions, and time durations for various actions. The code also sets default values for these parameters.",
        "type": "comment"
    },
    "238": {
        "file_id": 22,
        "content": "    # - Hold is equivalent to keyDown. I.e., hold a key for a certain duration, probably while something else happens.\n    # - Press is equivalent to keyDown followed by keyUp, after a delay. I.e., press a key for a short duration.\n    ACTION_PRESS = 'press' # Equivalent to click on the mouse\n    ACTION_HOLD = 'hold'\n    ACTION_RELEASE = 'release'\n    MOUSE_TYPE = 'is_mouse'\n    KEY_TYPE = 'is_keyboard'\n    # List of keys currently held. To be either released by specific calls or after timeout (max iterations).\n    # {\n    #     self.KEY_KEY: key,\n    #     self.EXPIRATION_KEY: self.MAX_ITERATIONS\n    # }\n    held_keys = []\n    held_buttons = []\n    # Used currently due to an issue with pause in RDR2\n    backup_held_keys = []\n    backup_held_buttons = []\n    def __init__(self) -> None:\n        \"\"\"Initialize the IO environment class\"\"\"\n        self.ahk = AHK()\n        #PyDirectInput is only used for key pressing, so no need for mouse checks\n        pydirectinput.FAILSAFE = False\n    def pop_held_button(self, button):",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:95-124"
    },
    "239": {
        "file_id": 22,
        "content": "This code initializes an IO environment class, defines actions as press and hold for keys and release for buttons, and manages held_keys and held_buttons lists for key releases or timeout. A backup list is used due to pause issues in RDR2. The code uses AHK (AutoHotkey) and PyDirectInput for key pressing but not mouse checks.",
        "type": "comment"
    },
    "240": {
        "file_id": 22,
        "content": "        self._mouse_button_up(button)\n        # Remove from held list\n        for i in range(len(self.held_buttons)):\n            if self.held_buttons[i][self.BUTTON_KEY] == button:\n                self.held_buttons.pop(i)\n                break\n        time.sleep(self.RELEASE_DEFAULT_BLOCK_TIME)\n        self._to_message(self.held_buttons, self.ACTION_RELEASE, self.MOUSE_TYPE)\n    def put_held_button(self, button):\n        for e in self.held_buttons:\n            if e[self.BUTTON_KEY] == button:\n                logger.warn(f'Button {button} already being held.')\n                return\n        else:\n            entry = {\n                self.BUTTON_KEY: button,\n                self.EXPIRATION_KEY: self.MAX_ITERATIONS\n            }\n            self.held_buttons.append(entry)\n            self._mouse_button_down(button)\n            time.sleep(self.HOLD_DEFAULT_BLOCK_TIME)\n            self._to_message(self.held_buttons, self.ACTION_HOLD, self.MOUSE_TYPE)\n    def _mouse_button_down(self, button):\n        self.ahk.click(button=button, direction='D')",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:126-160"
    },
    "241": {
        "file_id": 22,
        "content": "The code handles mouse button events (up and down) and manages a list of held buttons. The `_mouse_button_up` function removes the corresponding button from the held list, sleeps for a default release time, and sends a release message. The `put_held_button` function checks if the button is already being held, adds it to the held list with an expiration timestamp, performs a mouse button down action, sleeps for a default hold time, and sends a hold message.",
        "type": "comment"
    },
    "242": {
        "file_id": 22,
        "content": "    def _mouse_button_up(self, button):\n        self.ahk.click(button=button, direction='U')\n    def pop_held_keys(self, key):\n        if self.check_held_keys(keys = [key]):\n            pydirectinput.keyUp(key)\n            time.sleep(self.RELEASE_DEFAULT_BLOCK_TIME)\n            self.held_keys.pop()\n        else:\n            pydirectinput.keyUp(key) # Just as a guarantee to up an untracked key\n            logger.warn(f'Key {key} was not being held at top.')\n        self._to_message(self.held_keys, self.ACTION_RELEASE, self.KEY_TYPE)\n    def put_held_keys(self, key):\n        top_key = _safe_list_get(self.held_keys, -1, self.KEY_KEY)\n        if key == top_key:\n            logger.warn(f'Key {key} already being held.')\n        else:\n            entry = {\n                self.KEY_KEY: key,\n                self.EXPIRATION_KEY: self.MAX_ITERATIONS\n            }\n            self.held_keys.append(entry)\n            pydirectinput.keyDown(key)\n            time.sleep(self.HOLD_DEFAULT_BLOCK_TIME)\n            self._to_message(self.held_keys, self.ACTION_HOLD, self.KEY_TYPE)",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:163-196"
    },
    "243": {
        "file_id": 22,
        "content": "This code contains several functions for handling key inputs in a game environment. The `_mouse_button_up` function handles mouse button releases, `pop_held_keys` pops held keys when released, `put_held_keys` adds new keys to be held, and all these operations send messages to the system.",
        "type": "comment"
    },
    "244": {
        "file_id": 22,
        "content": "    def check_held_keys(self, keys):\n        result = False\n        if keys is not None and len(keys) != 0:\n            for e in self.held_keys:\n                k = e[self.KEY_KEY]\n                if k in keys:\n                    result = True\n                    break\n        return result\n    def _to_message(self, list, purpose, type):\n        if type == self.KEY_TYPE:\n            vals = ', '.join(f'{e[self.KEY_KEY]}:{e[self.EXPIRATION_KEY]}' for e in list)\n            msg = f'Held keys after {purpose}: {vals}'\n        elif type == self.MOUSE_TYPE:\n            vals = ', '.join(f'{e[self.BUTTON_KEY]}:{e[self.EXPIRATION_KEY]}' for e in list)\n            msg = f'Held button after {purpose}: {vals}'\n        logger.write(msg)\n        return msg\n    def update_timeouts(self):\n        if self.held_keys is None or len(self.held_keys) == 0:\n            return\n        tmp_list = []\n        for e in self.held_keys:\n            t = e[self.EXPIRATION_KEY] - 1\n            if t <= 0:\n                key = e[self.KEY_KEY]\n                logger.warn(f'Releasing key {key} after timeout.')",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:199-239"
    },
    "245": {
        "file_id": 22,
        "content": "The code contains functions to check if any keys are being held, convert a list of events into a message format, and update the timeout for held keys. It also logs warnings when a key is released due to reaching its timeout.",
        "type": "comment"
    },
    "246": {
        "file_id": 22,
        "content": "                pydirectinput.keyUp(key)\n                time.sleep(0.1)\n            else:\n                e[self.EXPIRATION_KEY] = t\n                tmp_list.append(e)\n        self.held_keys = tmp_list.copy()\n        del tmp_list\n        tmp_list = []\n        for e in self.held_buttons:\n            t = e[self.EXPIRATION_KEY] - 1\n            if t <= 0:\n                button = e[self.BUTTON_KEY]\n                logger.warn(f'Releasing mouse button {button} after timeout.')\n                self._mouse_button_up(button)\n                time.sleep(0.1)\n            else:\n                e[self.EXPIRATION_KEY] = t\n                tmp_list.append(e)\n        self.held_buttons = tmp_list.copy()\n        del tmp_list\n    def handle_hold_in_pause(self):\n        self.backup_held_keys = self.held_keys.copy()\n        if self.backup_held_keys is not None and self.backup_held_keys != []:\n            for e in self.backup_held_keys:\n                pydirectinput.keyUp(e[self.KEY_KEY])\n        self.held_keys = []\n        self.backup_held_buttons = self.held_buttons.copy()",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:240-277"
    },
    "247": {
        "file_id": 22,
        "content": "This code handles key and mouse button timeouts. It releases keys after their expiration time and checks if any held buttons have timed out, logging a warning and releasing the mouse button with a delay. The function also clears held_keys and held_buttons lists at the end.",
        "type": "comment"
    },
    "248": {
        "file_id": 22,
        "content": "        if self.backup_held_buttons is not None and self.backup_held_buttons != []:\n            for e in self.backup_held_buttons:\n                self._mouse_button_up(e[self.BUTTON_KEY])\n        self.held_buttons = []\n    def handle_hold_in_unpause(self):\n        buttons_hold = False\n        keys_hold = False\n        if self.backup_held_buttons is not None and self.backup_held_buttons != []:\n            for e in self.backup_held_buttons:\n                self._mouse_button_down(e[self.BUTTON_KEY])\n            buttons_hold = True\n            self.held_buttons = self.backup_held_buttons.copy()\n        time.sleep(.1)\n        if self.backup_held_keys is not None and self.backup_held_keys != []:\n            for e in self.backup_held_keys:\n                pydirectinput.keyDown(e[self.KEY_KEY])\n            keys_hold = True\n            self.held_keys = self.backup_held_keys.copy()\n        if buttons_hold or keys_hold:\n            time.sleep(1)\n    def list_session_screenshots(self, session_dir: str = config.work_dir):",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:278-310"
    },
    "249": {
        "file_id": 22,
        "content": "This code handles holding down buttons and keys in a game environment by backing up the held states, simulating the hold for 1 second, and then clearing the backup.",
        "type": "comment"
    },
    "250": {
        "file_id": 22,
        "content": "        # List all files in dir starting with \"screen\"\n        screenshots = [f for f in os.listdir(session_dir) if os.path.isfile(os.path.join(session_dir, f)) and f.startswith(\"screen\")]\n        # Sort list by creation time\n        screenshots.sort(key=lambda x: os.path.getctime(os.path.join(session_dir, x)))\n        return screenshots\n    def mouse_move_normalized(self, x, y, relative = False, from_center = False):\n        logger.debug(f'noormalized game coord x {x} y {y} relative {relative} fc {from_center}')\n        w, h = config.game_resolution\n        offset = 0\n        if from_center is True:\n            offset = .5 # Center of the game screen in normalized coordinates\n        gx = int((x-offset) * w)\n        gy = int((y-offset) * h)\n        self.mouse_move(x = gx, y = gy, relative = relative)\n    def _mouse_coord_to_abs_win(self, coord, width_or_height):\n        abs_coord = ((self.WIN_NORM_MAX * coord) / width_or_height) + (-1 if coord < 0 else 1)\n        return int(abs_coord)\n    # If either relative or not, always pass in-game coordinates",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:312-342"
    },
    "251": {
        "file_id": 22,
        "content": "Code snippet contains three functions: \n1. `screenshots` - lists and sorts files in a directory named \"screen\" based on their creation time.\n2. `mouse_move_normalized` - takes x, y coordinates to move the mouse, allowing for normalized (0-1) game coordinates or absolute screen coordinates with optional relative/from center parameters.\n3. `_mouse_coord_to_abs_win` - converts mouse coordinates to absolute window coordinates based on the given width or height.",
        "type": "comment"
    },
    "252": {
        "file_id": 22,
        "content": "    # This implementation is not fully functional and was intended to address game-category specific issues first\n    def mouse_move(self, x, y, relative=False):\n        extra = ctypes.c_ulong(0)\n        ii_ = Input_I()\n        logger.debug(f'game coord x {x} y {y} relative {relative}')\n        event_flag = self.MOUSEEVENTF_MOVE\n        if relative is False:\n            event_flag = self.MOUSEEVENTF_ABSOLUT | self.MOUSEEVENTF_MOVE\n            corner = config.game_region\n            x = x + corner[0]\n            y = y + corner[1]\n            logger.debug(f'screen x {x} y {y}')\n            x = self._mouse_coord_to_abs_win(x, config.screen_resolution[0])\n            y = self._mouse_coord_to_abs_win(y, config.screen_resolution[1])\n            logger.debug(f'windows x {x} y {y}')\n        ii_.mi = MouseInput(int(x), int(y), 0, event_flag, 0, ctypes.pointer(extra))\n        command = Input(ctypes.c_ulong(0), ii_)\n        ctypes.windll.user32.SendInput(1, ctypes.pointer(command), ctypes.sizeof(command))\n    def mouse_move_horizontal_angle(self, theta):",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:343-371"
    },
    "253": {
        "file_id": 22,
        "content": "This code implements the `mouse_move` function, which handles mouse movement events. It also includes a separate `mouse_move_horizontal_angle` function. The implementation is not fully functional and focuses on addressing game-category specific issues first. If relative mouse movement is specified, it calculates the absolute Windows coordinates based on screen resolution. The code uses C types and functions from the ctypes library for input handling and sends input using SendInput from user32 module.",
        "type": "comment"
    },
    "254": {
        "file_id": 22,
        "content": "        distance = _theta_calculation(theta)\n        self.mouse_move(distance, 0, relative=True)\n    def mouse_click(self, button, duration = None, clicks=1):\n        self.mouse_click_button(button, duration, clicks)\n    def mouse_click_button(self, button, duration = None, clicks=1):\n        button = self.map_button(button)\n        if duration is None:\n            self.ahk.click(click_count=clicks, button=button, relative=False)\n        else:\n            self._mouse_button_down(button)\n            time.sleep(duration)\n            self._mouse_button_up(button)\n    def mouse_hold(self, button, duration = None):\n        if duration is None:\n            self.mouse_hold_button(button)\n        else:\n            self._mouse_button_down(button)\n            time.sleep(duration)\n            self._mouse_button_up(button)\n    def mouse_hold_button(self, button):\n        button = self.map_button(button)\n        self.put_held_button(button)\n    def mouse_release(self, button):\n        self.mouse_release_button(button)\n    def mouse_release_button(self, button):",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:372-413"
    },
    "255": {
        "file_id": 22,
        "content": "The code defines methods for mouse actions such as move, click, hold, and release. The methods handle different cases of duration (None or specified) and the number of clicks/button presses. It uses AutoHotkey library to perform these actions on the computer's UI.",
        "type": "comment"
    },
    "256": {
        "file_id": 22,
        "content": "        button = self.map_button(button)\n        self.pop_held_button(button)\n    def get_mouse_position(self) -> Tuple[int, int]:\n        return self.ahk.get_mouse_position()\n    def clip_check_horizonal_angle(self, theta):\n        result = False\n        pixels = _theta_calculation(theta)\n        mx, _ = self.get_mouse_position()\n        if pixels > 0 and mx + pixels > config.game_resolution[0]:\n            result = True\n        elif pixels < 0 and mx + pixels < 0:\n            result = True\n        return result\n    def _check_multi_key(self, input):\n        if input is not None and len(input) > 1:\n            if type(input) is list:\n                return (True, input)\n            else:\n                key_tokens = input.split(',')\n                keys = []\n                for k in key_tokens:\n                    k = k.strip()\n                    if k != '':\n                        k = self.map_key(k)\n                        keys.append(k)\n                if len(keys) == 0:\n                    return (False, None)",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:415-453"
    },
    "257": {
        "file_id": 22,
        "content": "Function map_button called to map the button, and then pop_held_button is used to remove it. get_mouse_position returns x and y coordinates from ahk. get_mouse_position(). clip_check_horizonal_angle checks if angle pixels are within resolution bounds. _check_multi_key checks if input contains multiple keys, returning True/False with the key(s) if it does.",
        "type": "comment"
    },
    "258": {
        "file_id": 22,
        "content": "                elif len(keys) == 1:\n                    return (False, keys[0])\n                else:\n                    return (True, keys)\n        else:\n            return (False, None)\n    # Special function to facilitate multi-key combos from GPT-4V like \"io_env.key_hold('w,space')\", which are commonly generated\n    def _multi_key_action(self, keys, action, duration = 2):\n        actions = [self.ACTION_PRESS, self.ACTION_HOLD, self.ACTION_RELEASE]\n        if action not in actions:\n            logger.warn(f'Invalid action: {action}. Ignoring it.')\n        # Act in order, release in reverse\n        for key in keys:\n            # Special case to facilitate multi-key combos\n            if key != keys[-1]:\n                action = self.ACTION_HOLD\n            if action == self.ACTION_PRESS:\n                self.key_press(key)\n            elif action == self.ACTION_HOLD:\n                self.key_hold(key)\n        if duration is None:\n            duration = 0.3\n        time.sleep(duration)\n        for key in reversed(keys):",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:454-488"
    },
    "259": {
        "file_id": 22,
        "content": "This code handles key input in different scenarios. If there's only one key, it returns (False, key). Otherwise, it returns (True, keys) or (False, None) if the storage is empty. The _multi_key_action function performs actions on each key in order, releases them in reverse, and can take a duration argument for waiting before releasing the keys. It also includes a check to ensure the action parameter is valid and warns if it's not.",
        "type": "comment"
    },
    "260": {
        "file_id": 22,
        "content": "            self.key_release(key)\n    def key_press(self, key, duration=None):\n        if key in self.ALIASES_MOUSE_REDIRECT:\n            self.mouse_click_button(key, duration)\n        key = self.map_key(key)\n        f, keys = self._check_multi_key(key)\n        if f == True:\n            self._multi_key_action(keys, self.ACTION_PRESS, duration)\n        else:\n            if duration is None:\n                pydirectinput.keyDown(key)\n                time.sleep(.2)\n                pydirectinput.keyUp(key)\n            else:\n                pydirectinput.keyDown(key)\n                time.sleep(duration)\n                pydirectinput.keyUp(key)\n    def key_hold(self, key, duration=None):\n        if key in self.ALIASES_MOUSE_REDIRECT:\n            self.mouse_hold_button(key, duration)\n        key = self.map_key(key)\n        f, keys = self._check_multi_key(key)\n        if f == True:\n            self._multi_key_action(keys, self.ACTION_HOLD, duration)\n        else:\n            if duration is not None:\n                pydirectinput.keyDown(key)",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:489-527"
    },
    "261": {
        "file_id": 22,
        "content": "The code defines three methods: 'key_release', 'key_press', and 'key_hold'. These methods handle key events in the context of a game. The 'key_release' method is responsible for releasing keys, while 'key_press' and 'key_hold' are for pressing and holding keys, respectively. The code also handles multi-key actions, and interacts with the 'pydirectinput' library to perform key actions on the system.",
        "type": "comment"
    },
    "262": {
        "file_id": 22,
        "content": "                time.sleep(duration)\n                pydirectinput.keyUp(key)\n            else:\n                self.put_held_keys(key)\n    def key_release(self, key):\n        if key in self.ALIASES_MOUSE_REDIRECT:\n            self.mouse_release_button(key)\n        key = self.map_key(key)\n        self.pop_held_keys(key)\n    def release_held_keys(self):\n        for i in range(len(self.held_keys)):\n            self.held_keys.pop()\n    def release_held_buttons(self):\n        for i in range(len(self.held_buttons)):\n            self._mouse_button_up(self.held_buttons[i][self.BUTTON_KEY])\n    ALIASES_RIGHT_MOUSE = ['right', 'rightbutton', 'rightmousebutton', 'r', 'rbutton', 'rmouse', 'rightmouse', 'rm', 'mouseright', 'mouserightbutton']\n    ALIASES_LEFT_MOUSE = ['left', 'leftbutton', 'leftmousebutton', 'l', 'lbutton', 'lmouse', 'leftmouse', 'lm', 'mouseleft', 'mouseleftbutton']\n    ALIASES_CENTER_MOUSE = ['middle', 'middelbutton', 'middlemousebutton', 'm', 'mbutton', 'mmouse', 'middlemouse', 'center', 'c', 'centerbutton', 'centermouse', 'cm', 'mousecenter', 'mousecenterbutton']",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:528-556"
    },
    "263": {
        "file_id": 22,
        "content": "The code defines functions for handling key releases in a game input environment. The `key_release` function handles mouse button releases, the `release_held_keys` function clears the list of held keys, and the `release_held_buttons` function releases all held buttons. The code also includes aliases for left, right, center mouse buttons, and corresponding mouse actions.",
        "type": "comment"
    },
    "264": {
        "file_id": 22,
        "content": "    ALIASES_MOUSE_REDIRECT = set(ALIASES_RIGHT_MOUSE + ALIASES_LEFT_MOUSE + ALIASES_CENTER_MOUSE) - set(['r', 'l', 'm', 'c'])\n    # @TODO mapping can be improved\n    def map_button(self, button):\n        if button is None or button == '':\n            logger.error('Empty Button.')\n            raise Exception(f'Empty mouse button IO: {button}')\n        if len(button) > 1:\n            button = button.lower().replace('_', '').replace(' ', '')\n        if button in self.ALIASES_RIGHT_MOUSE:\n            return self.RIGHT_MOUSE_BUTTON\n        elif button in self.ALIASES_LEFT_MOUSE:\n            return self.LEFT_MOUSE_BUTTON\n        elif button in self.ALIASES_CENTER_MOUSE:\n            return self.MIDDLE_MOUSE_BUTTON\n        return button\n    ALIASES_RIGHT_SHIFT_KEY = ['rshift', 'right shift', 'rightshift', 'shift right', 'shiftright']\n    ALIASES_LEFT_SHIFT_KEY = ['lshift', 'left shift', 'leftshift', 'shift left', 'shiftleft']\n    ALIASES_SHIFT_KEY = ALIASES_RIGHT_SHIFT_KEY + ALIASES_LEFT_SHIFT_KEY\n    ALIASES_RIGHT_ALT_KEY = ['ralt', 'right alt', 'rightalt', 'alt right', 'altright']",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:557-583"
    },
    "265": {
        "file_id": 22,
        "content": "This code maps mouse button and keyboard inputs to their respective IO identifiers. It creates sets of aliases for right, left, and center mouse buttons, as well as specific keyboard shift and alt keys. The `map_button` function takes a string input representing the button or key and returns its corresponding identifier based on the provided aliases. If an empty or invalid input is given, it logs an error and raises an exception.",
        "type": "comment"
    },
    "266": {
        "file_id": 22,
        "content": "    ALIASES_LEFT_ALT_KEY = ['lalt', 'left alt', 'leftalt', 'alt left', 'altleft']\n    ALIASES_ALT_KEY = ALIASES_RIGHT_ALT_KEY + ALIASES_LEFT_ALT_KEY\n    ALIASES_RIGHT_CONTROL_KEY = ['rctrl', 'right ctrl', 'rightctrl', 'ctrl right', 'ctrlright', 'rcontrol', 'right control', 'rightcontrol', 'control right', 'contorlright']\n    ALIASES_LEFT_CONTROL_KEY = ['lctrl', 'left ctrl', 'leftctrl', 'ctrl left', 'ctrlleft', 'lcontrol', 'left control', 'leftcontrol', 'control left', 'contorlleft']\n    ALIASES_CONTROL_KEY = ALIASES_RIGHT_CONTROL_KEY + ALIASES_LEFT_CONTROL_KEY\n    ALIASES_SPACE_KEY = [' ', 'whitespace', 'spacebar', 'space bar']\n    # @TODO mapping can be improved\n    def map_key(self, key):\n        if key is None or key == '':\n            logger.error('Empty key.')\n            raise Exception(f'Empty key IO: {key}')\n        if len(key) > 1:\n            key = key.lower().replace('_', '').replace('-', '')\n        elif len(key) == 1:\n            key = key.lower()\n        if key in self.ALIASES_LEFT_SHIFT_KEY:",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:584-605"
    },
    "267": {
        "file_id": 22,
        "content": "This code defines aliases for various keyboard keys and then maps the given key to its alias. If the key is empty, it logs an error and raises an exception. It preprocesses the key by converting it to lowercase, removing underscores, and hyphens if applicable.",
        "type": "comment"
    },
    "268": {
        "file_id": 22,
        "content": "            return 'shift'\n        elif key in self.ALIASES_RIGHT_SHIFT_KEY:\n            return 'shift'\n        if key in self.ALIASES_LEFT_ALT_KEY:\n            return 'alt'\n        elif key in self.ALIASES_RIGHT_ALT_KEY:\n            return 'alt'\n        if key in self.ALIASES_LEFT_CONTROL_KEY:\n            return 'ctrl'\n        elif key in self.ALIASES_RIGHT_CONTROL_KEY:\n            return 'ctrl'\n        if key in self.ALIASES_SPACE_KEY:\n            return 'space'\n        return key\ndef _theta_calculation(theta):\n    \"\"\"\n    Calculates the adjusted theta value based on the configured mouse move factor.\n    Parameters:\n    - theta: The original theta value to be adjusted.\n    \"\"\"\n    return theta * (150 / 9)\ndef _safe_list_get(list, idx, key = None, default = None):\n    try:\n        return list[idx][key]\n    except IndexError:\n        return default",
        "type": "code",
        "location": "/cradle/gameio/io_env.py:606-640"
    },
    "269": {
        "file_id": 22,
        "content": "The code snippet defines a function that returns the corresponding key name for a given key. It handles special keys like shift, alt, ctrl, and space. There is also a separate function for calculating an adjusted theta value based on mouse move factor configuration. Lastly, there is a utility function to safely get values from lists using index and key.",
        "type": "comment"
    },
    "270": {
        "file_id": 23,
        "content": "/cradle/gameio/lifecycle/ui_control.py",
        "type": "filepath"
    },
    "271": {
        "file_id": 23,
        "content": "The code handles game management and error logging, using libraries such as OpenCV for image manipulation and template-based icon replacement. It captures screenshots and extracts relevant information to perform the desired actions.",
        "type": "summary"
    },
    "272": {
        "file_id": 23,
        "content": "import os, math\nimport time\nfrom typing import Any\nimport pydirectinput\nimport pyautogui\nfrom PIL import Image, ImageDraw, ImageFont\nimport cv2\nimport numpy as np\nimport torch\nfrom torchvision.ops import box_convert\nimport supervision as sv\nimport mss\nimport mss.tools\nfrom MTM import matchTemplates\nfrom cradle.config import Config\nfrom cradle.log import Logger\nfrom cradle.gameio import IOEnvironment\nfrom cradle.utils.template_matching import match_template_image\nconfig = Config()\nlogger = Logger()\nio_env = IOEnvironment()\nPAUSE_SCREEN_WAIT = 1\ndef pause_game():\n    if not is_env_paused():\n        io_env.handle_hold_in_pause()\n        pydirectinput.press('esc')\n        time.sleep(PAUSE_SCREEN_WAIT)\n    else:\n        logger.debug(\"The environment does not need to be paused!\")\n    # While game is paused, quickly re-center mouse location on x axis to avoid clipping at game window border with time\n    io_env.mouse_move(config.game_resolution[0] // 2, config.game_resolution[1] // 2, relative=False)\ndef unpause_game():\n    if is_env_paused():",
        "type": "code",
        "location": "/cradle/gameio/lifecycle/ui_control.py:1-44"
    },
    "273": {
        "file_id": 23,
        "content": "This code is defining a function `pause_game()` that pauses the game by pressing 'esc' and waiting for the pause screen to load, and another function `unpause_game()` that resumes the game if it was previously paused. It also centers the mouse location on the x-axis while the game is paused to avoid clipping at the game window border.",
        "type": "comment"
    },
    "274": {
        "file_id": 23,
        "content": "        pydirectinput.press('esc')\n        time.sleep(PAUSE_SCREEN_WAIT)\n        io_env.handle_hold_in_unpause()\n    else:\n        logger.debug(\"The environment is not paused!\")\ndef exit_back_to_pause():\n    max_steps = 10\n    back_steps = 0\n    while not is_env_paused() and back_steps < max_steps:\n        back_steps += 1\n        pydirectinput.press('esc')\n        time.sleep(PAUSE_SCREEN_WAIT)\n    if back_steps >= max_steps:\n        logger.warn(\"The environment fails to pause!\")\ndef exit_back_to_game():\n    exit_back_to_pause()\n    # Unpause the game, to keep the rest of the agent flow consistent\n    unpause_game()\ndef switch_to_game():\n    named_windows = pyautogui.getWindowsWithTitle(config.env_name)\n    if len(named_windows) == 0:\n        logger.error(f\"Cannot find the game window {config.env_name}!\")\n        return\n    else:\n        try:\n            named_windows[0].activate()\n        except Exception as e:\n            if \"Error code from Windows: 0\" in str(e):\n                # Handle pygetwindow exception\n                pass",
        "type": "code",
        "location": "/cradle/gameio/lifecycle/ui_control.py:45-86"
    },
    "275": {
        "file_id": 23,
        "content": "The code contains several methods to handle game environment pausing and resuming. `exit_back_to_pause()` tries to pause the game by repeatedly pressing 'esc', with a maximum of 10 attempts. If it fails, it logs a warning. `exit_back_to_game()` first calls `exit_back_to_pause()` and then unpauses the game using `unpause_game()`. `switch_to_game()` tries to switch to the game window by activating it if its title matches the expected name in the config file. If not found or any exception occurs, it logs an error.",
        "type": "comment"
    },
    "276": {
        "file_id": 23,
        "content": "            else:\n                raise e\n    time.sleep(1)\n    unpause_game()\n    time.sleep(1)\ndef take_screenshot(tid : float = 0.0,\n                    screen_region : tuple[int, int, int, int] = config.game_region,\n                    minimap_region : tuple[int, int, int, int] = config.minimap_region,\n                    include_minimap = True,\n                    draw_axis = False):\n    region = screen_region\n    region = {\n        \"left\": region[0],\n        \"top\": region[1],\n        \"width\": region[2],\n        \"height\": region[3],\n    }\n    output_dir = config.work_dir\n    # Save screenshots\n    screen_image_filename = output_dir + \"/screen_\" + str(tid) + \".jpg\"\n    with mss.mss() as sct:\n        screen_image = sct.grab(region)\n        image = Image.frombytes(\"RGB\", screen_image.size, screen_image.bgra, \"raw\", \"BGRX\")\n        image.save(screen_image_filename)\n    minimap_image_filename = \"\"\n    if include_minimap:\n        minimap_image_filename = output_dir + \"/minimap_\" + str(tid) + \".jpg\"\n        mm_region = minimap_region",
        "type": "code",
        "location": "/cradle/gameio/lifecycle/ui_control.py:87-124"
    },
    "277": {
        "file_id": 23,
        "content": "The code defines a function `take_screenshot` that captures screenshots of the specified game region and optionally the minimap. It saves the screen and minimap images in the output directory with timestamps appended to filenames. The function raises exceptions if there are errors during screenshot capture. It uses the mss library for screen grabbing and Pillow module for image processing.",
        "type": "comment"
    },
    "278": {
        "file_id": 23,
        "content": "        mm_region = {\n            \"left\": mm_region[0],\n            \"top\": mm_region[1],\n            \"width\": mm_region[2],\n            \"height\": mm_region[3],\n        }\n        with mss.mss() as sct:\n            minimap_image = sct.grab(mm_region)\n            mm_image = Image.frombytes(\"RGB\", minimap_image.size, minimap_image.bgra, \"raw\", \"BGRX\")\n            mm_image.save(minimap_image_filename)\n        clip_minimap(minimap_image_filename)\n    if draw_axis:\n        # Draw axis on the screenshot\n        draw = ImageDraw.Draw(screen_image)\n        width, height = screen_image.size\n        cx, cy = width // 2, height // 2\n        draw.line((cx, 0, cx, height), fill=\"blue\", width=3)  # Y\n        draw.line((0, cy, width, cy), fill=\"blue\", width=3)  # X\n        font = ImageFont.truetype(\"arial.ttf\", 30)\n        offset_for_text = 30\n        interval = 0.1\n        for i in range(10):\n            if i > 0:\n                draw.text((cx + interval * (i ) * width // 2, cy), str(i ), fill=\"blue\", font = font)\n                draw.text((cx - interval * (i) * width // 2, cy), str(-i), fill=\"blue\", font = font)",
        "type": "code",
        "location": "/cradle/gameio/lifecycle/ui_control.py:125-155"
    },
    "279": {
        "file_id": 23,
        "content": "This code captures a minimap image from the screen, saves it to file, and then draws axes on the main screenshot. The captured minimap is obtained using the mss library, with region specified by mm_region variable. The main screenshot's image is manipulated for drawing axes and text labels at various positions.",
        "type": "comment"
    },
    "280": {
        "file_id": 23,
        "content": "                draw.text((cx - offset_for_text - 10, cy + interval * (i ) * height // 2), str(-i), fill=\"blue\", font = font)\n            draw.text((cx - offset_for_text, cy - interval * (i ) * height // 2), str(i), fill=\"blue\", font = font)\n        axes_image_filename = output_dir + \"/axes_screen_\" + str(tid) + \".jpg\"\n        screen_image.save(axes_image_filename)\n    return screen_image_filename, minimap_image_filename\ndef segment_minimap(screenshot_path):\n    tid = time.time()\n    output_dir = config.work_dir\n    minimap_image_filename = output_dir + \"/minimap_\" + str(tid) + \".jpg\"\n    minimap_region = config.base_minimap_region\n    minimap_region = [int(x * (config.game_resolution[0] / config.base_resolution[0]) ) for x in minimap_region] # (56, 725, 56 + 320, 725 + 320)\n    minimap_region[2] += minimap_region[0]\n    minimap_region[3] += minimap_region[1]\n    # Open the source image file\n    with Image.open(screenshot_path) as source_image:\n        # Crop the image using the crop_rectangle\n        cropped_minimap = source_image.crop(minimap_region)",
        "type": "code",
        "location": "/cradle/gameio/lifecycle/ui_control.py:156-180"
    },
    "281": {
        "file_id": 23,
        "content": "This code segment saves a screenshot, crops the minimap region from it, and creates axes images by drawing positive and negative numbers. It uses the OpenCV library for image manipulation.",
        "type": "comment"
    },
    "282": {
        "file_id": 23,
        "content": "        # Save the cropped image to a new file\n        cropped_minimap.save(minimap_image_filename)\n    clip_minimap(minimap_image_filename)\n    return minimap_image_filename\ndef is_env_paused():\n    is_paused = False\n    confidence_threshold = 0.85\n    # Multiple-scale-template-matching example, decide whether the game is paused according to the confidence score\n    pause_clock_template_file = './res/icons/clock.jpg'\n    screenshot = take_screenshot(time.time(), include_minimap=False)[0]\n    match_info = match_template_image(screenshot, pause_clock_template_file, debug=True, output_bb=True, save_matches=True, scale='full')\n    is_paused = match_info[0]['confidence'] >= confidence_threshold\n    # Renaming pause candidate screenshot to ease debugging or gameplay scenarios\n    os.rename(screenshot, screenshot.replace('screen', 'pause_screen_candidate'))\n    return is_paused\ndef clip_minimap(minimap_image_filename):\n    image = cv2.imread(minimap_image_filename)\n    # Get the dimensions of the image\n    height, width = image.shape[:2]",
        "type": "code",
        "location": "/cradle/gameio/lifecycle/ui_control.py:182-214"
    },
    "283": {
        "file_id": 23,
        "content": "The code checks if the game is paused by comparing the confidence score from matching a pause clock template image with the current screenshot. It saves the cropped minimap to a new file and renames the pause candidate screenshot for debugging or gameplay scenarios.",
        "type": "comment"
    },
    "284": {
        "file_id": 23,
        "content": "    # Create a mask of the same size as the image, initialized to white\n    mask = np.ones((height, width, 3), dtype=np.uint8) * 255\n    # Define the size of the triangular mask at each corner\n    triangle_size = int(180 * config.resolution_ratio)\n    # Draw black triangles on the four corners of the mask\n    # Top-left corner\n    cv2.fillConvexPoly(mask, np.array([[0, 0], [triangle_size, 0], [0, triangle_size]]), 0)\n    # Top-right corner\n    cv2.fillConvexPoly(mask, np.array([[width, 0], [width - triangle_size, 0], [width, triangle_size]]), 0)\n    # Bottom-left corner\n    cv2.fillConvexPoly(mask, np.array([[0, height], [0, height - triangle_size], [triangle_size, height]]), 0)\n    # Bottom-right corner\n    cv2.fillConvexPoly(mask, np.array([[width, height], [width, height - triangle_size], [width - triangle_size, height]]), 0)\n    # Apply the mask to the image\n    masked_image = cv2.bitwise_and(image, mask)\n    # Save the result\n    cv2.imwrite(minimap_image_filename, masked_image)\ndef annotate_with_coordinates(image_source, boxes, logits, phrases):",
        "type": "code",
        "location": "/cradle/gameio/lifecycle/ui_control.py:216-242"
    },
    "285": {
        "file_id": 23,
        "content": "The code generates a mask for an image with black triangles at each corner, applies the mask to the image, and saves the result. The function takes image source, bounding boxes, logits, and phrases as inputs and seems to be part of an annotation process.",
        "type": "comment"
    },
    "286": {
        "file_id": 23,
        "content": "    h, w, _ = image_source.shape\n    boxes = boxes * torch.Tensor([w, h, w, h])\n    xyxy = box_convert(boxes=boxes, in_fmt=\"cxcywh\", out_fmt=\"xyxy\").numpy()\n    logger.debug(f\"boxes: {boxes}, xyxy: {xyxy}\")\n    detections = sv.Detections(xyxy=xyxy)\n    # Without coordinates normalization\n    labels = [\n        f\"{phrase} {' '.join(map(str, ['x=', round((xyxy_s[0]+xyxy_s[2])/(2*w), 2), ', y=', round((xyxy_s[1]+xyxy_s[3])/(2*h), 2)]))}\"\n        for phrase, xyxy_s\n        in zip(phrases, xyxy)\n    ]\n    box_annotator = sv.BoxAnnotator()\n    annotated_frame = cv2.cvtColor(image_source, cv2.COLOR_RGB2BGR)\n    annotated_frame = box_annotator.annotate(scene=annotated_frame, detections=detections, labels=labels)\n    return annotated_frame\nclass CircleDetector:\n    def __init__(self,resolution_ratio):\n        if resolution_ratio <= .67:  # need super resolution\n            self.sr_model = cv2.dnn_superres.DnnSuperResImpl_create()\n            self.k = 2 if resolution_ratio <=.5 else 3\n            self.sr_model.readModel(f'./res/models/ESPCN_x{self.k}.pb')",
        "type": "code",
        "location": "/cradle/gameio/lifecycle/ui_control.py:243-268"
    },
    "287": {
        "file_id": 23,
        "content": "Code takes an image, detects objects within it using a Detections class, and annotates the image with box labels indicating object positions. The code also initializes a CircleDetector instance for potential future super resolution processing based on the input's resolution ratio.",
        "type": "comment"
    },
    "288": {
        "file_id": 23,
        "content": "            self.sr_model.setModel('espcn', self.k)\n        else:\n            self.sr_model = None\n    def get_theta(self, origin_x, origin_y, center_x, center_y):\n        '''\n        The origin of the image coordinate system is usually located in the upper left corner of the image, with the x-axis to the right indicating a positive direction and the y-axis to the down indicating a positive direction. Using vertical upward as the reference line, i.e. the angle between it and the negative direction of the y-axis\n        '''\n        theta = math.atan2(center_x - origin_x, origin_y - center_y)\n        theta = math.degrees(theta)\n        return theta\n    def detect(self, img_file,\n        yellow_range=np.array([[140, 230, 230], [170, 255, 255]]),\n        gray_range=np.array([[165, 165, 165], [175, 175, 175]]),\n        red_range=np.array([[0, 0, 170], [30, 30, 240]]),\n        detect_mode='yellow & gray',\n        debug=False\n    ):\n        image = cv2.imread(img_file)\n        # super resolution according to resolution ratio",
        "type": "code",
        "location": "/cradle/gameio/lifecycle/ui_control.py:269-293"
    },
    "289": {
        "file_id": 23,
        "content": "The code snippet appears to be from a computer vision script used for image processing. It contains a method for applying super resolution based on a given model, determining the angle between two points using the atan2 function and converting it to degrees, and a detect method that reads an image file and applies color filters to detect yellow, gray, or red objects in the image. The code also takes in optional parameters for setting the detection mode (yellow & gray or just yellow) and a debug flag.",
        "type": "comment"
    },
    "290": {
        "file_id": 23,
        "content": "        if self.sr_model is not None:\n            image = self.sr_model.upsample(image)\n            if self.k == 3:\n                image = cv2.resize(image, (0, 0), fx=0.5, fy=0.5)\n        origin = (image.shape[0] // 2, image.shape[1] // 2)\n        circles = cv2.HoughCircles(cv2.cvtColor(image, cv2.COLOR_BGR2GRAY), cv2.HOUGH_GRADIENT, 1, 10, param1=200,param2=10, minRadius=5 * 2, maxRadius=8 * 2)\n        theta = 0x3f3f3f3f\n        measure = {'theta': theta, 'distance': theta, 'color': np.array([0, 0, 0]), 'confidence': 0, 'vis': image,\n                   'center': origin}\n        circles_info = []\n        if circles is not None:\n            circles = np.round(circles[0, :]).astype(\"int\")\n            for (x, y, r) in circles:\n                # Crop the circle from the original image\n                circle_img = np.zeros_like(image)\n                cv2.circle(circle_img, (x, y), r, (255, 255, 255), thickness=-1)\n                circle = cv2.bitwise_and(image, circle_img)\n                # Define range for red color and create a mask",
        "type": "code",
        "location": "/cradle/gameio/lifecycle/ui_control.py:294-317"
    },
    "291": {
        "file_id": 23,
        "content": "Performing image resizing, upsampling and converting to grayscale before applying Hough transform for detecting circles in the image.",
        "type": "comment"
    },
    "292": {
        "file_id": 23,
        "content": "                red_mask = cv2.inRange(circle, red_range[0], red_range[1])\n                gray_mask = cv2.inRange(circle, gray_range[0], gray_range[1])\n                yellow_mask = cv2.inRange(circle, yellow_range[0], yellow_range[1])\n                # Count red pixels in the circle\n                red_count = cv2.countNonZero(red_mask)\n                gray_count = cv2.countNonZero(gray_mask)\n                yellow_count = cv2.countNonZero(yellow_mask)\n                # Add circle information and color counts to the list\n                circles_info.append({\n                    \"center\": (x, y),\n                    \"radius\": r,\n                    \"red_count\": red_count,\n                    \"gray_count\": gray_count,\n                    \"yellow_count\": yellow_count\n                })\n            # Sort the circles based on yellow_count, gray_count, and red_count\n            if 'red' in detect_mode:\n                circles_info.sort(key=lambda c: (c['red_count'], c['yellow_count'], c['gray_count']), reverse=True)",
        "type": "code",
        "location": "/cradle/gameio/lifecycle/ui_control.py:318-338"
    },
    "293": {
        "file_id": 23,
        "content": "This code segment uses OpenCV to apply masks for red, gray, and yellow colors on a circle image. It counts non-zero pixels in each mask and stores the circle's center, radius, and color count information in a list. The circles are then sorted based on their red, yellow, and gray pixel counts in descending order if 'red' is specified in detect_mode.",
        "type": "comment"
    },
    "294": {
        "file_id": 23,
        "content": "                detect_criterion = lambda circle: circle[\"red_count\"] >= 5\n            else:\n                circles_info.sort(key=lambda c: (c['yellow_count'], c['gray_count'], c['red_count']), reverse=True)\n                detect_criterion = lambda circle: circle[\"gray_count\"] >= 5 or circle[\"yellow_count\"] >= 5\n            for circle in circles_info:\n                center_x, center_y, radius = circle[\"center\"][0], circle[\"center\"][1], circle[\"radius\"]\n                if detect_criterion(circle):\n                    theta = self.get_theta(*origin, center_x, center_y)\n                    dis = np.sqrt((center_x - origin[0]) ** 2 + (center_y - origin[1]) ** 2)\n                    measure = {'theta': theta, 'distance': dis,\n                               'color': \"yellow\" if circle[\"yellow_count\"] >= 5 else \"gray\", 'confidence': 1,\n                               'center': (center_x, center_y),\n                               'bounding_box': (center_x - radius, center_y - radius, 2 * radius, 2 * radius)}",
        "type": "code",
        "location": "/cradle/gameio/lifecycle/ui_control.py:339-354"
    },
    "295": {
        "file_id": 23,
        "content": "Checks if a circle has at least 5 yellow or gray counts, then sorts circles by those counts in descending order. If a circle meets the detection criterion, it creates a measure object with its theta, distance, color (gray or yellow), confidence, and bounding box coordinates.",
        "type": "comment"
    },
    "296": {
        "file_id": 23,
        "content": "                    break\n            if debug:\n                for i, circle in enumerate(circles_info):\n                    cv2.circle(image, circle[\"center\"], circle[\"radius\"], (0, 255, 0), 2)\n                    cv2.putText(image, str(i + 1), (circle[\"center\"][0] - 5, circle[\"center\"][1] + 4),\n                                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)\n                measure['vis'] = image\n        return theta, measure\nclass IconReplacer:\n    def __init__(self, template_path = './res/icons/keys'):\n        self.template_paths = [os.path.join(template_path, filename) for filename in os.listdir(template_path)]\n    def __call__(self, image_paths):\n        return self.replace_icon(image_paths)\n    def _drawBoxesOnRGB(self, image, tableHit, boxThickness=2, boxColor=(255, 255, 00), showLabel=False, labelColor=(255, 255, 0), labelScale=0.5):\n        \"\"\"\n        Return a copy of the image with predicted template locations as bounding boxes overlaid on the image\n        The name of the template can also be displayed on top of the bounding box with showLabel=True",
        "type": "code",
        "location": "/cradle/gameio/lifecycle/ui_control.py:355-378"
    },
    "297": {
        "file_id": 23,
        "content": "This code defines a class IconReplacer that replaces icons in an image using templates. The constructor takes a template path and lists all files in the directory. The __call__ method takes a list of image paths and returns the result of replace_icon method. The _drawBoxesOnRGB method is used to draw bounding boxes on the image with predicted template locations.",
        "type": "comment"
    },
    "298": {
        "file_id": 23,
        "content": "        Parameters\n        ----------\n        - image  : image in which the search was performed\n        - tableHit: list of hit as returned by matchTemplates or findMatches\n        - boxThickness: int\n                        thickness of bounding box contour in pixels\n        - boxColor: (int, int, int)\n                    RGB color for the bounding box\n        - showLabel: Boolean\n                    Display label of the bounding box (field TemplateName)\n        - labelColor: (int, int, int)\n                    RGB color for the label\n        Returns\n        -------\n        outImage: RGB image\n                original image with predicted template locations depicted as bounding boxes\n        \"\"\"\n        # Convert Grayscale to RGB to be able to see the color bboxes\n        if image.ndim == 2:\n            outImage = cv2.cvtColor(image, cv2.COLOR_GRAY2RGB) # convert to RGB to be able to show detections as color box on grayscale image\n        else:\n            outImage = image.copy()\n        for _, row in tableHit.iterrows():",
        "type": "code",
        "location": "/cradle/gameio/lifecycle/ui_control.py:380-408"
    },
    "299": {
        "file_id": 23,
        "content": "This code snippet defines a function that takes an image, hit list, box thickness, box color, show label flag, and label color as input. It returns the original image with predicted template locations depicted as bounding boxes. If the image is grayscale, it converts to RGB for visualization purposes before iterating over the hit list to draw bounding boxes on the image.",
        "type": "comment"
    }
}