{
    "summary": "This code creates a colorful logger, handles image processing in text and JSON, provides helper functions for error displaying, decoding, and file path normalization. It normalizes log lines, replaces candidate strings with Markdown formatted text for images, handles specific formats, excludes lines matching filter list, and finally joins processed lines into a single log string.",
    "details": [
        {
            "comment": "The code imports necessary libraries and defines a class called ColorFormatter, which inherits from logging.Formatter. This class assigns different colors to log levels for formatting purposes. The code also creates a metaclass named Logger as a Singleton, with its log file set to 'cradle.log'.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/log/logger.py\":0-43",
            "content": "import json\nimport logging\nimport os\nimport re\nimport sys\nimport ast\nfrom pathlib import PureWindowsPath\nfrom colorama import Fore, Back, Style, init as colours_on\nfrom cradle.utils import Singleton\nfrom cradle.config import Config\nfrom cradle.utils.encoding_utils import decode_base64\nfrom cradle.utils.string_utils import hash_text_sha256\nconfig = Config()\ncolours_on(autoreset=True)\nclass ColorFormatter(logging.Formatter):\n    # Change your colours here. Should use extra from log calls.\n    COLORS = {\n        \"WARNING\": Fore.YELLOW,\n        \"ERROR\": Fore.RED,\n        \"DEBUG\": Fore.GREEN,\n        \"INFO\": Fore.WHITE,\n        \"CRITICAL\": Fore.RED + Back.WHITE\n    }\n    def format(self, record):\n        color = self.COLORS.get(record.levelname, \"\")\n        if color:\n            record.name = color + record.name\n            record.msg = record.msg + Style.RESET_ALL\n        return logging.Formatter.format(self, record)\nclass Logger(metaclass=Singleton):\n    log_file = 'cradle.log'\n    DOWNSTREAM_MASK = \"\\n>> Downstream - A:\\n\""
        },
        {
            "comment": "This code initializes a logger with various handlers and formats, including a StreamHandler for stdout (INFO level), StreamHandler for stderr (ERROR level), and a FileHandler for a log file in debug mode. The logger is then obtained using logging.getLogger(\"UAC Logger\").",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/log/logger.py\":44-74",
            "content": "    UPSTREAM_MASK = \"\\n>> Upstream - R:\\n\"\n    def __init__(self):\n        self.to_file = False\n        self._configure_root_logger()\n    def _configure_root_logger(self):\n        format = f'%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n        formatter = logging.Formatter(format)\n        c_formatter = ColorFormatter(format)\n        stdout_handler = logging.StreamHandler(sys.stdout)\n        stdout_handler.setLevel(logging.INFO)\n        stdout_handler.setFormatter(c_formatter)\n        stderr_handler = logging.StreamHandler()\n        stderr_handler.setLevel(logging.ERROR)\n        stderr_handler.setFormatter(c_formatter)\n        file_handler = logging.FileHandler(filename=os.path.join(config.log_dir, self.log_file), mode='w', encoding='utf-8')\n        file_handler.setLevel(logging.DEBUG)\n        file_handler.setFormatter(formatter)\n        logging.basicConfig(level=logging.DEBUG, handlers=[stdout_handler, stderr_handler, file_handler])\n        self.logger = logging.getLogger(\"UAC Logger\")\n    def _log("
        },
        {
            "comment": "This code defines a logger class with methods for logging different levels of messages. The `_log` method is used to log messages at specific levels, while the other methods (`critical`, `error`, `debug`, `write`) are used to simplify logging messages with optional titles and colors. The `write` method is used as a default logger when no specific level or message is provided.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/log/logger.py\":75-123",
            "content": "            self,\n            title=\"\",\n            title_color=Fore.WHITE,\n            message=\"\",\n            level=logging.INFO\n        ):\n        if message:\n            if isinstance(message, list):\n                message = \" \".join(message)\n        self.logger.log(level, message, extra={\"title\": title, \"color\": title_color})\n    def critical(\n            self,\n            message,\n            title=\"\"\n        ):\n        self._log(title, Fore.RED + Back.WHITE, message, logging.ERROR)\n    def error(\n            self,\n            message,\n            title=\"\"\n        ):\n        self._log(title, Fore.RED, message, logging.ERROR)\n    def debug(\n            self,\n            message,\n            title=\"\",\n            title_color=Fore.GREEN,\n        ):\n        self._log(title, title_color, message, logging.DEBUG)\n    def write(\n            self,\n            message=\"\",\n            title=\"\",\n            title_color=Fore.WHITE,\n        ):\n        self._log(title, title_color, message, logging.INFO)\n    def warn(\n            self,"
        },
        {
            "comment": "The code defines a class with methods for logging messages, errors, and error traces. The logger can accept message, title, and title color as parameters. An auxiliary function is provided to extract text between specific tokens from a given string.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/log/logger.py\":124-155",
            "content": "            message,\n            title=\"\",\n            title_color=Fore.YELLOW,\n        ):\n        self._log(title, title_color, message, logging.WARN)\n    def error_ex(self, exception: Exception):\n        traceback = exception.__traceback__\n        while traceback:\n            self.error(\"{}: {}\".format(traceback.tb_frame.f_code.co_filename, traceback.tb_lineno))\n            traceback = traceback.tb_next\n#\n# Functions below this line are just auxiliary to code to process a log file to facilitate debug. Code is very brittle.\n#\ndef _extract_text_between_tokens(text, start_token=\"(?<=;base64,)\", end_token=\"(?=\\\")\", escape = False):\n    # Escape the tokens if they contain special regex characters\n    if escape is True:\n        start_token = re.escape(start_token)\n        end_token = re.escape(end_token)\n    # Regex pattern to capture text between start_token and end_token\n    pattern = rf'{start_token}(.*?){end_token}'\n    # Extracting all occurrences\n    extracted_texts = re.findall(pattern, text)\n    return extracted_texts"
        },
        {
            "comment": "This code defines a function _replacer that takes in text, encoded_images, image_paths, and work_dir as parameters. It handles the case where image_paths is None or empty by replacing them with '<$img_placeholder$>'. If there are more encoded images than image paths, it assigns the first path to all remaining images. For each encoded image, it checks if a corresponding key exists in image_paths dictionary or if its value is '<$bin_placeholder$>'. If so, it reconstructs the image by writing the decoded base64 data to a file and updates image_paths accordingly. Finally, it replaces the text with the corresponding image path.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/log/logger.py\":158-185",
            "content": "def _replacer(text, encoded_images, image_paths, work_dir):\n    if image_paths is None or len(image_paths) == 0:\n        image_paths = ['<$img_placeholder$>']\n    for i in range(len(encoded_images)):\n        if len(image_paths) == 1 and len(encoded_images) > len(image_paths):\n            paths_idx = 0\n            text = text.replace(encoded_images[i], image_paths[paths_idx])\n        else:\n            key = hash_text_sha256(encoded_images[i])\n            encoded_image = encoded_images[i]\n            if key not in image_paths.keys() or image_paths[key] == '<$bin_placeholder$>':\n                # Re-construct image, then replace\n                file_name = f\"base64_rec_{i}.jpg\"\n                path = os.path.join(work_dir, file_name)\n                with open(path, \"wb\") as f:\n                    f.write(decode_base64(encoded_image))\n                image_paths[key] = path\n            else:\n                path = image_paths[key]\n                if not os.path.exists(path):\n                    with open(path, \"wb\") as f:"
        },
        {
            "comment": "This code is responsible for processing a given input string. It replaces certain characters with their escaped versions, and then attempts to evaluate the processed string as a JSON object using `ast.literal_eval()`. If an error occurs during evaluation, it prints the SyntaxError message and a nearby section of the problematic string. The code also defines two additional functions: `_extract_image_hashes()` that extracts image hash information from a text string, and `decode_base64()` (not shown) which decodes Base64 encoded strings.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/log/logger.py\":186-221",
            "content": "                        f.write(decode_base64(encoded_image))\n            text = text.replace(encoded_image, json.dumps(image_paths[key], ensure_ascii=False).strip('\"'))\n    return text\ndef _extract_image_hashes(text):\n    map = dict()\n    hash_list = _extract_text_between_tokens(text, \"|>.\", \".<|\", escape = True)\n    for i in range(len(hash_list)):\n        # Extract mapping info\n        hash_info = hash_list[i].split(\" \")\n        map[hash_info[2].split(\",\")[0]] = hash_info[4]\n        # Remove line from log\n        text = text.replace(hash_list[i], \"\")\n    return (map, text)\ndef process_string(input_str):\n    processed_str = input_str.replace(\"\\\\\", \"\\\\\\\\\")\n    processed_str = processed_str.replace(\"'text': \\\"\", \"'text': '\").replace(\".\\\"}]}\", \".'}]}\")\n    processed_str = processed_str.replace(\"\\\"\", \"\\\\\\\"\")\n    try:\n        msgs = ast.literal_eval(processed_str)\n        json_obj = msgs\n    except SyntaxError as e:\n        print(f\"Syntax error: {e}\")\n        print(\"Error may be near:\", processed_str[max(0, e.offset - 10):e.offset + 10])"
        },
        {
            "comment": "This code snippet handles JSON decoding errors and displays the error location by printing a span of 10 characters before and after the position. It also defines a function, `process_log_messages`, which filters log lines based on specific keywords and joins them back into a single string.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/log/logger.py\":222-248",
            "content": "    except json.JSONDecodeError as e: #SyntaxError\n        print()\n        error_position = e.pos\n        start = max(0, error_position - 10)  # Show 10 characters before the error position\n        end = min(len(processed_str), error_position + 10)  # Show 10 characters after the error position\n        span = processed_str[start:end]\n        print(f'Error near: {span}')\n        print(f'Exact error position: {error_position}')\n    return json_obj\ndef process_log_messages(work_dir):\n    log_path = os.path.join(work_dir, \"logs/cradle.log\")\n    with open(log_path, \"r\", encoding=\"utf-8\") as fd:\n        log = fd.read()\n    filter_list = ['|>..<|', 'httpcore.http11 - DEBUG', 'httpcore.connection - DEBUG', 'asyncio - DEBUG', 'httpx - DEBUG', 'matplotlib.pyplot - DEBUG', 'openai._base_client - DEBUG - Request options:']\n    log_lines = []\n    for line in log.split('\\n'):\n        if any(substring in line for substring in filter_list):\n            continue\n        log_lines.append(line)\n    log = '\\n'.join(log_lines)"
        },
        {
            "comment": "The code reads a log file and identifies sections containing either system messages or images. It extracts these sections, converts them to valid JSON format, and replaces the original line in the log with formatted text/code blocks for readability. The extracted image paths are also normalized.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/log/logger.py\":250-274",
            "content": "    hash_file_maps, log = _extract_image_hashes(log)\n    encoded_images = _extract_text_between_tokens(log)\n    log = _replacer(log, encoded_images, hash_file_maps, work_dir)\n    md_log = []\n    img_start_token = ';base64,'\n    img_end_token = 'g\"'\n    msg_start_token = '[{\"role\": \"system\",'\n    msg_end_token = '}]}]'\n    for line in log.split('\\n'):\n        if msg_start_token in line:\n            candidates = _extract_text_between_tokens(line, msg_start_token, msg_end_token, escape=True)\n            if len(candidates) > 0:\n                msgs = f'{msg_start_token}{candidates[0]}{msg_end_token}'#.replace('\\\\', '\\\\\\\\')\n                obj = json.loads(msgs)\n                obj_str = json.dumps(obj, indent=4, ensure_ascii=False)\n                line = \"\\n````text\\n\" + obj_str + \"\\n````\\n\\n\"\n        if img_start_token in line:\n            candidates = _extract_text_between_tokens(line, img_start_token, img_end_token)\n            for candidate in candidates:\n                norm_path = os.path.normpath(candidate+'g')"
        },
        {
            "comment": "This code snippet normalizes file paths and replaces a candidate string with Markdown formatted text for image links, handling specific formats, and excluding lines matching a filter list. It then joins the processed lines into a single log string before returning it.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/log/logger.py\":275-289",
            "content": "                norm_work_dir = PureWindowsPath(os.path.normpath(work_dir)).as_posix()\n                rel_path = PureWindowsPath(os.path.relpath(norm_path, norm_work_dir)).as_posix()\n                new_substxt = \"\\n````\\n\" + f'![{norm_path}](../{rel_path})'.replace('\\\\','/').replace('//','/') + \"\\n````text\\n\"\n                line = line.replace(candidate, new_substxt)\n        elif re.match('^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2},\\d{3}', line):\n            line = f'{line}\\n'\n        if any(substring in line for substring in filter_list):\n            continue\n        md_log.append(line)\n    log = '\\n'.join(md_log)\n    return log"
        }
    ]
}