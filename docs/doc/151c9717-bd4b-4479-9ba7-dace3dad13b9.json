{
    "summary": "This code creates a navigation skill for game characters using OpenCV, detects contours and lines, and computes turn angles considering deviations. It displays images, takes input, and outputs the real turn angle.",
    "details": [
        {
            "comment": "This code defines a navigation skill that navigates an existing waypoint path in the minimap. It has parameters for maximum iterations and debug mode. The `cv_navigation` function handles the actual navigation process using OpenCV. The game region is defined from the configuration file.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/navigation.py\":0-36",
            "content": "import time\nimport os\nimport math\nimport cv2\nimport numpy as np\nfrom cradle.config import Config\nfrom cradle.log import Logger\nfrom cradle.gameio.atomic_skills.move import turn, move_forward, stop_horse\nfrom cradle.gameio.lifecycle.ui_control import take_screenshot\nfrom cradle.gameio.skill_registry import register_skill\nfrom cradle.gameio.composite_skills.go_to_icon import match_template\nconfig = Config()\nlogger = Logger()\nDEFAULT_NAVIGATION_ITERATIONS = 100\nNAVIGATION_TERMINAL_THRESHOLD = 100\n@register_skill(\"navigate_path\")\ndef navigate_path(iterations = DEFAULT_NAVIGATION_ITERATIONS, debug = False):\n    \"\"\"\n    Navigates an existing waypoint path in the minimap.\n    Parameters:\n    - iterations: How many maximum calculation loops to navigate. Default value is 100.\n    - debug: Whether to show debug information. Default value is False.\n    \"\"\"\n    time.sleep(1)\n    cv_navigation(iterations, debug)\ndef cv_navigation(total_iterations, terminal_threshold=NAVIGATION_TERMINAL_THRESHOLD, debug = False):\n    game_screen_region = config.game_region"
        },
        {
            "comment": "This code segment is responsible for navigating a game character. It checks if the text from OCR is different from the previous iteration and disables OCR if it is. It also controls the horse's movement by turning, moving forward, stopping if necessary, and ensures it doesn't move too fast. The code logs information at each step for debugging purposes.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/navigation.py\":37-68",
            "content": "    minimap_region = config.minimap_region\n    save_dir = config.work_dir\n    terminal_threshold *= config.resolution_ratio\n    warm_up = True\n    waypoint_marker_filename = './res/icons/red_marker.jpg'\n    try:\n        for step in range(total_iterations):\n            if config.ocr_different_previous_text:\n                logger.write(\"The text is different from the previous one.\")\n                config.ocr_enabled = False  # disable ocr\n                config.ocr_different_previous_text = False  # reset\n                break\n            timestep = time.time()\n            logger.debug(f\"step {step}, {timestep}\")\n            if step > 0:\n                if abs(turn_angle) > 65:\n                    stop_horse()\n                    time.sleep(0.3)\n                    warm_up = True\n                turn(turn_angle)\n                if warm_up:\n                    move_forward(1)\n                    warm_up = False\n                else:\n                    move_forward(0.3)\n                time.sleep(0.1) # avoid running too fast"
        },
        {
            "comment": "The code snippet captures game screenshots and minimap images, then measures the distance and angle to a waypoint marker. If the distance is below a certain threshold and angle isn't too sharp, it stops the horse, turns towards the marker, and ends if the angle is within range. If any exception occurs, it logs a warning and stops the horse.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/navigation.py\":70-91",
            "content": "            game_image, minimap_image = take_screenshot(timestep, game_screen_region, minimap_region, draw_axis=False)\n            theta, measure = match_template(os.path.join(save_dir, f\"minimap_{timestep}.jpg\"), waypoint_marker_filename, config.resolution_ratio, debug=False)\n            logger.debug(f\"distance  {measure['distance']}\")\n            if measure['distance'] < terminal_threshold * 1.5:\n                stop_horse()\n            if measure['distance'] < terminal_threshold and abs(theta) < 90:\n                logger.debug('success! Reach the red marker.')\n                stop_horse()\n                time.sleep(1)\n                theta, measure = match_template(os.path.join(save_dir, f\"minimap_{timestep}.jpg\"), waypoint_marker_filename, config.resolution_ratio, debug=False)\n                turn(theta * 1.2)\n                break\n            turn_angle = calculate_turn_angle(timestep, debug)\n    except Exception as e:\n        logger.warn(f\"Error in cv_navigation: {e}. Usually not a problem.\")\n        stop_horse()"
        },
        {
            "comment": "This function calculates the turn angle based on an image and returns the contours of the top 5 areas sorted by area. The code reads an image, converts it to HSV space, calculates the image center, defines a range for red color, creates a mask, dilates the mask, finds contours in the mask and sorts them by area.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/navigation.py\":94-125",
            "content": "def calculate_turn_angle(tid, debug = False, show_image = False):\n    output_dir = config.work_dir\n    minimap_path = output_dir + \"/minimap_\" + str(tid) + \".jpg\"\n    output_path = output_dir + \"/direction_map_\" + str(tid) + \".jpg\"\n    image = cv2.imread(minimap_path)\n    # Convert the image to HSV space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Calculate image center\n    image_center = np.array([image.shape[1] // 2, image.shape[0] // 2])\n    width, height  = image_center\n    center_x = width\n    center_y = height\n    # Define range for red color\n    lower_red_1 = np.array([0, 80,80])\n    upper_red_1 = np.array([10,255,255])\n    # Threshold the HSV image to get the red regions\n    mask1 = cv2.inRange(hsv, lower_red_1, upper_red_1)\n    mask = mask1\n    kernel = np.ones((3,3), np.uint8)\n    mask_upper_bottom = cv2.dilate(mask, kernel, iterations = 2)\n    def get_contour(mask):\n        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        # Sort contours by area and get the top 5"
        },
        {
            "comment": "This function uses OpenCV to find the contour with the minimum distance to the image center and applies a HoughLinesP transformation on that contour to detect lines. The parameters control the line detection threshold, minimum line length, and maximum gap between lines. If no lines are detected or the number of lines is less than 10 after several iterations, the function returns None. Otherwise, it returns the detected lines.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/navigation.py\":126-147",
            "content": "        contours = sorted(contours, key=cv2.contourArea, reverse=True)[:5]\n        # Find the minimum distance from each contour to the image center\n        def min_distance_from_center(contour):\n            return min([  np.linalg.norm(np.array(point[0]) - image_center) for point in contour])\n        # Find the contour with the minimum distance to the image center\n        closest_contour = min(contours, key=min_distance_from_center)\n        output_mask = np.zeros_like(mask)\n        contour = cv2.drawContours(output_mask, [closest_contour], -1, (1), thickness=cv2.FILLED) * 255\n        lines = None\n        minLineLength = width / 15\n        threshold = 10\n        while (lines is None or len(lines) < 10) and threshold > 0:\n            lines = cv2.HoughLinesP(contour, 1, np.pi / 180, threshold=threshold, minLineLength= minLineLength, maxLineGap=100)\n            if minLineLength <= 10:\n                threshold -= 1\n            minLineLength /= 1.1\n        if threshold == 0:\n            return None\n        return lines"
        },
        {
            "comment": "This code calculates the average slope of lines near the center of a mini-map by iterating through each line, checking its distance from the center point. It creates two blank images and uses the slope_to_angle function to convert slopes into angles in degrees. The process continues until it has gathered 5 such angle values for the central lines.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/navigation.py\":149-186",
            "content": "    lines = get_contour(mask)\n    lines_upper_bottom = get_contour(mask_upper_bottom)\n    if lines is None or lines_upper_bottom is None:\n        return 0\n    line_img = np.zeros_like(image)\n    upper_bottom_img = np.zeros_like(image)\n    def slope_to_angle(x1, y1, x2, y2):\n        dx = x2 - x1\n        dy = y2 - y1\n        angle_radians = math.atan2(dy, dx)\n        angle_degrees = math.degrees(angle_radians)\n        if angle_degrees < 0:\n            angle_degrees += 180\n        return angle_degrees\n    # Calcualte the average slope with the lines near the center of the mini-map\n    central_line_angles = []\n    central_dots = []\n    distance_threshold = height / 50\n    while len(central_line_angles) < 5:\n        central_line_angles = []\n        central_dots = []\n        for line in lines:\n            x1, y1, x2, y2 = line[0]\n            cv2.line(line_img, (x1, y1), (x2, y2), (255), 1)\n            cv2.line(image, (x1, y1), (x2, y2), (255), 1)\n            if (x1 - center_x)**2 + (y1 -center_y)**2 < distance_threshold**2 or (x2 - center_x)**2 + (y2 -center_y)**2 < distance_threshold**2:"
        },
        {
            "comment": "This code calculates the angle and determines central dots of lines within a specified distance threshold. It then calculates the y-coordinate of central lines to determine if the red line is in the upper or bottom half of the mini-map. The code also logs debug information, such as the distance threshold and central dots, for potential troubleshooting.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/navigation.py\":188-212",
            "content": "                angle_degrees = slope_to_angle(x1, y1, x2, y2)\n                central_line_angles.append(angle_degrees)\n                if (x1 - center_x)**2 + (y1 -center_y)**2 < (x2 - center_x)**2 + (y2 - center_y)**2:\n                    central_dots.append((x1, y1))\n                else:\n                    central_dots.append((x2, y2))\n        distance_threshold *= 1.2\n    if debug:\n        logger.debug(f\"distance_threshold {distance_threshold}\")\n        logger.debug(f\"central_dots {central_dots}\")\n    # Use the average of the y of the chosen lines to determine the red line is in the upper/bottom half of the mini-map\n    central_line_y = []\n    distance_threshold = height / 5\n    while not central_line_y:\n        for line in lines_upper_bottom:\n            cv2.line(upper_bottom_img, (x1, y1), (x2, y2), (255), 1)\n            x1, y1, x2, y2 = line[0]\n            if (x1 - center_x)**2 + (y1 - center_y)**2 < distance_threshold**2 or (x2 - center_x)**2 + (y2 - center_y)**2 < distance_threshold**2:\n                if (x1 - center_x)**2 + (y1 - center_y)**2 > (x2 - center_x)**2 + (y2 - center_y)**2:"
        },
        {
            "comment": "This code calculates the central line y-coordinates, updates distance threshold, determines if upper or lower based on average central line y, checks for deviation from center based on average central dots, calculates real turn angle considering the angle and whether it's upper or lower.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/navigation.py\":213-239",
            "content": "                    central_line_y.append(y1)\n                else:\n                    central_line_y.append(y2)\n        distance_threshold *= 1.2\n    angle_degrees = np.average(central_line_angles)\n    is_upper = np.average(central_line_y)  <= center_y * 1.05\n    deviation_angle_degrees = None\n    deviation_threshold = width / 10\n    central_dot_upper = True\n    if len(central_dots) > 0:\n        average_dot = np.average(central_dots, axis=0)\n        if (average_dot[0] - center_x)**2 + (average_dot[1] - center_y)**2 > deviation_threshold**2:\n            deviation_angle_degrees = slope_to_angle(average_dot[0], average_dot[1], center_x, center_y)\n            central_dot_upper = average_dot[1] <= center_y\n    def cal_real_turn_angle(angle_degrees, is_upper):\n        if angle_degrees > 90:\n            angle_degrees -= 180\n        # calculate turn angle(the angle between the red line and normal line)\n        # positive: right, negative: left\n        if angle_degrees < 0:\n            turn_angle = 90 + angle_degrees"
        },
        {
            "comment": "This function calculates the final turn angle based on the input angle_degrees and whether it is in the upper or lower half of the mini-map. It considers potential deviations by calculating a deviation_turn_angle, and adjusts the real_turn_angle accordingly. Finally, it scales the angle to account for small numerical precision issues and converts it to radians before calculating the slope.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/navigation.py\":240-267",
            "content": "        else:\n            turn_angle = -90 + angle_degrees\n        # process the angle if the red line is in the bottom half of the mini-map\n        if not is_upper:\n            if turn_angle > 0:\n                real_turn_angle = turn_angle - 180\n            else:\n                real_turn_angle = turn_angle + 180\n        else:\n            real_turn_angle = turn_angle\n        return real_turn_angle\n    red_line_turn_angle = cal_real_turn_angle(angle_degrees, is_upper)\n    real_turn_angle = red_line_turn_angle\n    if deviation_angle_degrees:\n        deviation_turn_angle = cal_real_turn_angle(deviation_angle_degrees, central_dot_upper)\n        if real_turn_angle * deviation_turn_angle > 0 and is_upper == central_dot_upper:\n            real_turn_angle = (real_turn_angle + deviation_turn_angle) / 2\n        else:\n            real_turn_angle = deviation_turn_angle\n    real_turn_angle *= 1.1\n    angle_radians = math.radians(real_turn_angle)\n    slope = math.tan(angle_radians)\n    if slope == 0:\n        slope = 0.0001"
        },
        {
            "comment": "Draws a green line to indicate the calculated turn direction. If central dots exist and average dot is outside of deviation threshold, mark it with a light blue dot.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/navigation.py\":268-294",
            "content": "    slope = 1 / slope\n    if debug:\n        logger.debug(f\"slope {slope}\")\n        logger.debug(f\"red_line_turn_angle {red_line_turn_angle}\")\n        logger.debug(f\"is_upper {is_upper}\")\n        if deviation_angle_degrees:\n            logger.debug(f\"deviation_turn_angle {deviation_turn_angle}\")\n            logger.debug(f\"central_dot_upper {central_dot_upper}\")\n        logger.debug(f\"real turn angle {real_turn_angle}\")\n    # Draw green line to show the calculated turn direction\n    offset = 50\n    if abs(slope * offset) >= center_y:\n        offset = (center_y - 1) / abs(slope)\n    end_x = center_x + offset\n    start_x = center_x - offset\n    end_y = center_y - slope * offset\n    start_y = center_y + slope * offset\n    cv2.line(image, (int(start_x), int(start_y)), (int(end_x), int(end_y)), (0, 255, 0), 2)\n    if len(central_dots) > 0 and (average_dot[0] - center_x)**2 + (average_dot[1] - center_y)**2 > deviation_threshold**2:\n        point = (int(average_dot[0]), int(average_dot[1]))\n        color = (0, 255, 255)"
        },
        {
            "comment": "Code draws a circle on an image, writes the image to output path, displays multiple images using cv2.imshow, waits for user input before closing windows, and returns the real turn angle.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/navigation.py\":295-312",
            "content": "        cv2.circle(image, point, 5, color, -1)\n    cv2.imwrite(output_path, image)\n    if show_image:\n        cv2.imshow('upper', upper_bottom_img)\n        cv2.imshow('Image with Lines', line_img)\n        cv2.imshow('Image', image)\n        cv2.imshow('mask_upper_bottom', mask_upper_bottom)\n        cv2.waitKey(0)\n        cv2.destroyAllWindows()\n    return real_turn_angle\n__all__ = [\n    \"navigate_path\",\n]"
        }
    ]
}