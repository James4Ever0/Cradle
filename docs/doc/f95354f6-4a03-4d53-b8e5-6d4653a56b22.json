{
    "summary": "The `JSONStructure` class manages data in an ordered dictionary and performs sorting/searching by timestamps. The `VideoFrameExtractor` initializes directories, handles frame caches, and runs the `VideoSubFinderWXW` executable on video files using specified CPU cores. The code defines CPU settings, execution command for frame extraction, and logs progress/exceptions with subprocess and os.listdir in a method called 'extract'.",
    "details": [
        {
            "comment": "The code defines a class named `JSONStructure` which has an ordered dictionary `data_structure` to store data. The `add_instance` method adds new instances with their timestamp to the data structure. If the timestamp already exists, it appends the instance to the existing timestamp; otherwise, it creates a new entry with incremented end index and sets the timestamp with its corresponding instance.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/video/VideoFrameExtractor.py\":0-35",
            "content": "import multiprocessing\nimport os\nfrom typing import Dict, Any, List\nimport subprocess\nimport shutil\nfrom collections import OrderedDict\nimport numpy as np\nfrom cradle.log import Logger\nfrom cradle.config import Config\nlogger = Logger()\nconfig = Config()\nclass JSONStructure:\n    def __init__(self):\n        self.data_structure: Dict[int, Dict[str, list[Dict[str, any]]]] = {}\n        self.end_index: int = -1\n    def add_instance(self, time_stamp: str, instance: dict[str, any]) -> None:\n        # Check if the timestamp already exists across all indices\n        exists = False\n        for index_data in self.data_structure.values():\n            if time_stamp in index_data:\n                # Timestamp already exists, append the instance to the existing timestamp\n                index_data[time_stamp].append(instance)\n                exists = True\n                break\n        if not exists:\n            # Timestamp is new, create a new entry and increment the end_index\n            self.end_index += 1\n            self.data_structure.setdefault(self.end_index, {}).setdefault(time_stamp, []).append(instance)"
        },
        {
            "comment": "The code contains a method to sort extracted data based on timestamps and another method to search across all indices for a specific type. The first method sorts the extracted data using lambda functions, then reconstructs the JSON structure with sorted data. The second method searches through each index's instances and their values, appending results if a match is found for the given type and non-empty values.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/video/VideoFrameExtractor.py\":37-59",
            "content": "    def sort_index_by_timestamp(self) -> None:\n        extracted_data = [(key, value) for entry in self.data_structure.values() for key, value in entry.items()]\n        sorted_data = sorted(extracted_data, key=lambda x: x[0])\n        # Reconstructing the JSON structure with sorted data\n        self.data_structure = OrderedDict({index: {key: value} for index, (key, value) in enumerate(sorted_data)})\n    def search_type_across_all_indices(self, search_type: str) -> list[dict[str, any]]:\n        results = []\n        # Sort the keys in ascending order\n        for index, index_data in sorted(self.data_structure.items()):\n            for object_id, instances in index_data.items():\n                for instance in instances:\n                    for type, values in instance.items():\n                        if type == search_type and values != \"\" and values != []:\n                            results.append({\"index\": index, \"object_id\": object_id, \"values\":values})\n        return results\nclass VideoFrameExtractor():"
        },
        {
            "comment": "Initializing the VideoFrameExtractor class by setting necessary paths and creating required directories. First, it copies a placeholder file to the work directory and sets the vsf_subtitle path. It then creates the extracted frame folder within the frame_output_dir. If the VideoSubFinderWXW file does not exist, it raises an exception.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/video/VideoFrameExtractor.py\":61-83",
            "content": "    def __init__(self) -> None:\n        self.path_vsf = config.VideoFrameExtractor_path\n        # Copy the placeholder file to the work_dir\n        run_placeholderfile_path = os.path.join(config.work_dir, 'test.srt')\n        if not os.path.exists(run_placeholderfile_path):\n            shutil.copy(config.VideoFrameExtractor_placeholderfile_path, run_placeholderfile_path)\n        self.vsf_subtitle = run_placeholderfile_path\n        self.frame_output_dir = os.path.join(config.work_dir, 'frame_output_dir')\n        self.extracted_frame_folder = os.path.join(self.frame_output_dir, \"RGBImages\")\n        os.makedirs(self.extracted_frame_folder, exist_ok=True)\n        # If self.path_vsf does not exist, throw a non-exist error\n        if not os.path.exists(self.path_vsf):\n            raise Exception(f\"VideoSubFinderWXW does not exist! Please install it according to the README.md.\")\n        # Create a folder to store the extracted frames\n        if not os.path.exists(self.frame_output_dir):\n            os.makedirs(self.frame_output_dir)"
        },
        {
            "comment": "The code contains two functions: 'delete_frame_cache' and 'run_sub_finder'. The 'delete_frame_cache' function deletes the cache of extracted frames from a previous run if there are any files in the specified frame output directory. The 'run_sub_finder' function runs the VideoSubFinderWXW.exe executable at path_vsf on a video file at video_path, using a specified number of CPU cores (calculated as 2/3 of the available cores plus 1). No usage is made of the vsf_subtitle argument.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/video/VideoFrameExtractor.py\":86-112",
            "content": "    def delete_frame_cache(self, frame_output_dir):\n        # Delete the cache of the extracted frames generated by the previous run\n        if len(os.listdir(frame_output_dir)) > 0:\n            for i in os.listdir(frame_output_dir):\n                path = os.path.join(frame_output_dir, i)\n                try:\n                    if os.path.isfile(path):\n                        os.remove(path)\n                    elif os.path.isdir(path):\n                        shutil.rmtree(path)\n                except PermissionError as e:\n                    logger.write(f\"Permission error: {e}\")\n                except Exception as e:\n                    logger.write(f\"An error occurred: {e}\")\n    def run_sub_finder(self, path_vsf, video_path, frame_output_dir, vsf_subtitle):\n        # path_vsf is the path of the VideoSubFinderWXW.exe\n        # vsf_subtitile is the path of the extracted sub titles (no usage), it should be ended with '.srt'\n        self.delete_frame_cache(frame_output_dir)\n        cpu_count = max(int(multiprocessing.cpu_count() * 2 / 3), 1)"
        },
        {
            "comment": "This code checks if the number of CPU cores is less than 4, and if so, sets it to at least 1. Then it sets default values for top-bottom-left-right end points in a video. It constructs a command with path to executable and arguments like video file path, frame output directory, start/end time, number of threads, etc. The code then tries to execute this command using subprocess.Popen and handles KeyboardInterrupt exceptions if any.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/video/VideoFrameExtractor.py\":113-139",
            "content": "        if cpu_count < 4:\n            cpu_count = max(multiprocessing.cpu_count() - 1, 1)\n        top_end = 0\n        bottom_end = 1\n        left_end = 0\n        right_end = 1\n        cmd = f\"{path_vsf} --use_cuda -c -r -i \\\"{video_path}\\\" -o \\\"{frame_output_dir}\\\" -ces \\\"{vsf_subtitle}\\\" \"\n        cmd += f\"-te {top_end} -be {bottom_end} -le {left_end} -re {right_end} -nthr {cpu_count} -nocrthr {cpu_count}\"\n        # Execute the command\n        try:\n            logger.write(f\"Extracting Informative Frames from {video_path} .....\")\n            startupinfo = None\n            if os.name == 'nt':\n                startupinfo = subprocess.STARTUPINFO()\n                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n                startupinfo.wShowWindow = subprocess.SW_HIDE\n            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, startupinfo=startupinfo)\n            try:\n                stdout, stderr = proc.communicate()\n            except KeyboardInterrupt:\n                logger.write(f\"Frame extraction stopped\")"
        },
        {
            "comment": "The code snippet is a part of the VideoFrameExtractor class. It contains a method named 'extract' that accepts a video_path as input. The 'extract' method uses os.listdir to list all files in the directory, selects only .jpeg and .jpg files, and returns their full paths along with the first 11 characters of each filename as timestamp in a list format. In case of exceptions during frame extraction, it writes \"Frame Extraction Failed! {e}\" to the logger and if frame extraction is successful, it writes \"Frame Extraction Completed! Total Frames: {len(os.listdir(self.extracted_frame_folder))}\" to the logger.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/video/VideoFrameExtractor.py\":141-160",
            "content": "            finally:\n                if proc.poll() is None:\n                    proc.terminate()\n            logger.write(f\"Frame Extraction Completed! Total Frames: {len(os.listdir(self.extracted_frame_folder))}\")\n        except Exception as e:\n            logger.write(f\"Frame Extraction Failed! {e}\")\n    def extract(self,video_path):\n        video_path = os.path.normpath(video_path)\n        self.run_sub_finder(self.path_vsf, video_path, self.frame_output_dir, self.vsf_subtitle)\n        # List all files in the directory, get full paths of jpeg files, and extract the first 11 characters of each filename as timestamp\n        extracted_frame_paths = [(os.path.join(self.extracted_frame_folder, file), file[:11]) for file in\n                                 os.listdir(self.extracted_frame_folder) if\n                                 file.endswith('.jpeg') or file.endswith('.jpg')]\n        return extracted_frame_paths"
        }
    ]
}