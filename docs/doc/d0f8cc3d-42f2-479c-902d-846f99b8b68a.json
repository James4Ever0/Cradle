{
    "summary": "This code is for a follow skill in the Cradle game, using CV_follow_circles function to prioritize yellow/gray circles. It initializes variables and queues, takes screenshots, OCR detection, and finds circle direction/distance. The follow function updates player position based on target theta, performs warm-up move, checks stuck situations, and moves robot randomly to get unstuck.",
    "details": [
        {
            "comment": "This code is for a \"follow\" skill in the Cradle game. It utilizes the CV_follow_circles function to prioritize following the yellow circle on the minimap, and if not detected, it follows the gray circle. The function takes iterations, follow distance threshold, and debug parameters as inputs. It initializes variables for saving directory, resolution ratio, CircleDetector instance, previous distance, previous theta, and counter.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/follow.py\":0-42",
            "content": "import time, os\nfrom collections import deque\nimport numpy as np\nimport cv2\nfrom cradle.config import Config\nfrom cradle.log import Logger\nfrom cradle.gameio.atomic_skills.move import turn, move_forward\nfrom cradle.gameio.lifecycle.ui_control import take_screenshot, CircleDetector\nfrom cradle.gameio.skill_registry import register_skill\nfrom cradle.utils.image_utils import minimap_movement_detection\nfrom cradle import constants\nconfig = Config()\nlogger = Logger()\nMAX_FOLLOW_ITERATIONS = 40\n@register_skill(\"follow\")\ndef follow():\n    \"\"\"\n    Follow target on the minimap.\n    \"\"\"\n    cv_follow_circles(MAX_FOLLOW_ITERATIONS, debug=False)\ndef cv_follow_circles(\n        iterations,\n        follow_dis_threshold=50,\n        debug=False,\n):\n    '''\n    Prioritize following the yellow circle. If not detected, then follow the gray circle.\n    '''\n    save_dir = config.work_dir\n    follow_dis_threshold *= config.resolution_ratio\n    is_move = False\n    circle_detector = CircleDetector(config.resolution_ratio)\n    previous_distance, previous_theta, counter = 0, 0, 0"
        },
        {
            "comment": "This code initializes two queues, one for minimap image filenames and the other for conditions. It then goes through a loop of iterations, taking screenshots at each step. If the OCR detects different text from previous steps, it disables OCR, resets the flag, and breaks the loop. The code stores minimap image filenames in the queue and retrieves adjacent filenames if the queue size is greater than max_q_size. It then uses circle_detector to find the direction and distance for following and checks if it's the first step or not.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/follow.py\":43-69",
            "content": "    max_q_size = 2\n    minimap_image_filename_q = deque(maxlen=max_q_size)\n    condition_q = deque(maxlen=max_q_size)\n    for step in range(iterations):\n        if debug:\n            logger.write(f'Go into combat #{step}')\n        if config.ocr_different_previous_text:\n            logger.write(\"The text is different from the previous one.\")\n            config.ocr_enabled = False # disable ocr\n            config.ocr_different_previous_text = False  # reset\n            break\n        timestep = time.time()\n        _, minimap_image_filename = take_screenshot(timestep, config.game_region, config.minimap_region, draw_axis=False)\n        minimap_image_filename_q.append(minimap_image_filename)\n        adjacent_minimaps = list(minimap_image_filename_q)[::max_q_size-1] if len(minimap_image_filename_q)>=max_q_size else None\n        # Find direction to follow\n        follow_theta, follow_info = circle_detector.detect(minimap_image_filename, debug=debug)\n        follow_dis = follow_info[constants.DISTANCE_TYPE]\n        if abs(follow_theta) <= 360 and step == 0:"
        },
        {
            "comment": "This code is part of a follow function in a game context. It updates the player's position based on the target theta, performs a warm-up move, and logs/visualizes its progress if debug mode is enabled. If the distance to the target is below a certain threshold, it sends a \"Keep with the companion\" message. The code then adjusts the rotation and movement based on the follow_theta and checks for stuck situations by detecting minimap movement.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/follow.py\":71-99",
            "content": "            turn(follow_theta)\n            move_forward(1) # warm up\n        if debug:\n            logger.debug(\n                f\"step {step:03d} | timestep {timestep} done | follow theta: {follow_theta:.2f} | follow distance: {follow_dis:.2f} | follow confidence: {follow_info['confidence']:.3f}\")\n            cv2.circle(follow_info['vis'], follow_info['center'], 1, (0, 255, 0), 2)\n            cv2.imwrite(os.path.join(save_dir, f\"minimap_{timestep}_follow_template.jpg\"), follow_info['vis'])\n        if debug and follow_dis < follow_dis_threshold:\n            logger.write('Keep with the companion')\n        if abs(follow_theta) <= 360 and step > 0:\n            turn(follow_theta)\n            if not is_move:\n                move_forward(0.8)\n                is_move = True\n            else:\n                move_forward(0.3)\n        else:\n            is_move = False\n        # Check stuck\n        if adjacent_minimaps:\n            condition, img_matches, average_distance = minimap_movement_detection(*adjacent_minimaps, threshold = 5)"
        },
        {
            "comment": "If debug mode is on, save the image of image matches at a specific directory. If not stuck, move robot randomly to get unstuck and wait for stability improvement. Update previous_distance and previous_theta with current values.",
            "location": "\"/media/root/Prima/works/github_code/Cradle/docs/src/cradle/gameio/composite_skills/follow.py\":101-122",
            "content": "            if debug:\n                cv2.imwrite(os.path.join(save_dir, f\"minimap_{timestep}_bfmatch.jpg\"),img_matches)\n            condition_q.append(~condition)\n            condition = all(condition_q)\n        else:\n            condition = abs(previous_distance - follow_dis) < 0.5 and abs(previous_theta - follow_theta) < 0.5\n        if condition:\n            if debug:\n                logger.debug('Move randomly to get unstuck')\n            turn(180),move_forward(np.random.randint(1, 6))\n            time.sleep(1)  # improve stability\n            turn(-90),move_forward(np.random.randint(1, 6))\n        previous_distance, previous_theta = follow_dis, follow_theta\n__all__ = [\n    \"follow\",\n]"
        }
    ]
}